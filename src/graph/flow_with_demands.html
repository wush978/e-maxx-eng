<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<!--?title Flows with demands -->
<h1 id="flows-with-demands">Flows with demands</h1>
<p>In a normal flow network the flow of an edge is only limited by the capacity <span class="math inline"><em>c</em>(<em>e</em>)</span> from above and by 0 from below. In this article we will discuss flow networks, where we additionally require the flow of each edge to have a certain amount, i.e. we bound the flow from below by a <strong>demand</strong> function <span class="math inline"><em>d</em>(<em>e</em>)</span>: <br /><span class="math display"><em>d</em>(<em>e</em>)≤<em>f</em>(<em>e</em>)≤<em>c</em>(<em>e</em>)</span><br /> So next each edge has a minimal flow value, that we have to pass along the edge.</p>
<p>This is a generalization of the normal flow problem, since setting <span class="math inline"><em>d</em>(<em>e</em>)=0</span> for all edges <span class="math inline"><em>e</em></span> gives a normal flow network. Notice, that in the normal flow network it is extremely trivial to find a valid flow, just setting <span class="math inline"><em>f</em>(<em>e</em>)=0</span> is already a valid one. However if the flow of each edge has to satisfy a demand, than suddenly finding a valid flow is already pretty complicated.</p>
<p>We will consider two problems:</p>
<ol style="list-style-type: decimal">
<li>finding an arbitrary flow that satisfies all constraints</li>
<li>finding a minimal flow that satisfies all constraints</li>
</ol>
<h2 id="finding-an-arbitrary-flow">Finding an arbitrary flow</h2>
<p>We make the following changes in the network. We add a new source <span class="math inline"><em>s</em>′</span> and a new sink <span class="math inline"><em>t</em>′</span>, a new edge from the source <span class="math inline"><em>s</em>′</span> to every other vertex, a new edge for every vertex to the sink <span class="math inline"><em>t</em>′</span>, and one edge from <span class="math inline"><em>t</em></span> to <span class="math inline"><em>s</em></span>. Additionally we define the new capacity function <span class="math inline"><em>c</em>′</span> as:</p>
<ul>
<li><span class="math inline"><em>c</em>′((<em>s</em>′,<em>v</em>)) = ∑<sub><em>u</em> ∈ <em>V</em></sub><em>d</em>((<em>u</em>, <em>v</em>))</span> for each edge <span class="math inline">(<em>s</em>′,<em>v</em>)</span>.</li>
<li><span class="math inline"><em>c</em>′((<em>v</em>, <em>t</em>′))=∑<sub><em>w</em> ∈ <em>V</em></sub><em>d</em>((<em>v</em>, <em>w</em>))</span> for each edge <span class="math inline">(<em>v</em>, <em>t</em>′)</span>.</li>
<li><span class="math inline"><em>c</em>′((<em>u</em>, <em>v</em>)) = <em>c</em>((<em>u</em>, <em>v</em>)) − <em>d</em>((<em>u</em>, <em>v</em>))</span> for each edge <span class="math inline">(<em>u</em>, <em>v</em>)</span> in the old network.</li>
<li><span class="math inline"><em>c</em>′((<em>t</em>, <em>s</em>)) = ∞</span></li>
</ul>
<p>If the new network has a saturating flow (a flow where each edge outgoing from <span class="math inline"><em>s</em>′</span> is completely filled, which is equivalent to every edge incoming to <span class="math inline"><em>t</em>′</span> is completely filled), then the network with demands has a valid flow, and the actual flow can be easily reconstructed from the new network. Otherwise there doesn't exist a flow that satisfies all conditions. Since a saturating flow has to be a maximum flow, it can be found by any maximum flow algorithm, like the <a href="./graph/edmonds_karp.html">Edmonds-Karp algorithm</a> or the <a href="./graph/push-relabel.html">Push-relabel algorithm</a>.</p>
<p>The correctness of these transformations is more difficult to understand. We can think of it in the following way: Each edge <span class="math inline"><em>e</em> = (<em>u</em>, <em>v</em>)</span> with <span class="math inline"><em>d</em>(<em>e</em>)&gt;0</span> is originally replaced by two edges: one with the capacity <span class="math inline"><em>d</em>(<em>i</em>)</span> , and the other with <span class="math inline"><em>c</em>(<em>i</em>)−<em>d</em>(<em>i</em>)</span>. We want to find a flow that saturates the first edge (i.e. the flow along this edge must be equal to its capacity). The second edge is less important - the flow along it can be anything, assuming that it doesn't exceed its capacity. Consider each edge that has to be saturated, and we perform the following operation: we draw the edge from the new source <span class="math inline"><em>s</em>′</span> to its end <span class="math inline"><em>v</em></span>, draw the edge from its start <span class="math inline"><em>u</em></span> to the new sink <span class="math inline"><em>t</em>′</span>, remove the edge itself, and from the old sink <span class="math inline"><em>t</em></span> to the old source <span class="math inline"><em>s</em></span> we draw an edge of infinite capacity. By these actions we simulate the fact that this edge is saturated - from <span class="math inline"><em>v</em></span> there will be an additionally <span class="math inline"><em>d</em>(<em>e</em>)</span> flow outgoing (we simulate it with a new source that feeds the right amount of flow to <span class="math inline"><em>v</em></span>), and <span class="math inline"><em>u</em></span> will also push <span class="math inline"><em>d</em>(<em>e</em>)</span> additional flow (but instead along the old edge, this flow will go directly to the new sink <span class="math inline"><em>t</em>′</span>). A flow with the value <span class="math inline"><em>d</em>(<em>e</em>)</span>, that originally flowed along the path <span class="math inline"><em>s</em> − … − <em>u</em> − <em>v</em> − …<em>t</em></span> can now take the new path <span class="math inline"><em>s</em>′−<em>v</em> − … − <em>t</em> − <em>s</em> − … − <em>u</em> − <em>t</em>′</span>. The only thing that got simplified in the definition of the new network, is that if procedure created multiple edges between the same pair of vertices, then they are combined to one single edge with the summed capacity.</p>
<h2 id="minimal-flow">Minimal flow</h2>
<p>Note that along the edge <span class="math inline">(<em>t</em>, <em>s</em>)</span> (from the old sink to the old source) with the capacity <span class="math inline">∞</span> flows the entire flow of the corresponding old network. I.e. the capacity of this edge effects the flow value of the old network. By giving this edge a sufficient large capacity (i.e. <span class="math inline">∞</span>), the flow of the old network is unlimited. By limiting this edge by smaller capacities, the flow value will decrease. However if we limit this edge by a too small value, than the network will not have a saturated solution, e.g. the corresponding solution for the original network will not satisfy the demand of the edges. Obviously here can use a binary search to find the lowest value with which all constraints are still satisfied. This gives the minimal flow of the original network.</p>
</body>
</html>
