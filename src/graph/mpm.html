<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<!--?title Maximum flow - MPM algorithm -->
<h1 id="maximum-flow---mpm-algorithm">Maximum flow - MPM algorithm</h1>
<p>MPM (Malhotra, Pramodh-Kumar and Maheshwari) algorithm solves the maximum flow problem in <span class="math inline"><em>O</em>(<em>V</em><sup>3</sup>)</span>. This algorithm is similar to <a href="./graph/dinic.html">Dinic's algorithm</a>.</p>
<h2 id="algorithm">Algorithm</h2>
<p>Like Dinic's algorithm, MPM runs in phases, during each phase we find the blocking flow in the layered network of the residual network of <span class="math inline"><em>G</em></span>. The main difference from Dinic's is how we find the blocking flow. Consider the layered network <span class="math inline"><em>L</em></span>. For each node we define its' <em>inner potential</em> and <em>outer potential</em> as:</p>
<p><br /><span class="math display">$$\begin{align}
p_{in}(v) &amp;= \sum\limits_{(u, v)\in L}(c(u, v) - f(u, v)) \\\\
p_{out}(v) &amp;= \sum\limits_{(v, u)\in L}(c(v, u) - f(v, u))
\end{align}$$</span><br /></p>
<p>Also we set <span class="math inline"><em>p</em><sub><em>i</em><em>n</em></sub>(<em>s</em>)=<em>p</em><sub><em>o</em><em>u</em><em>t</em></sub>(<em>t</em>)=∞</span>. Given <span class="math inline"><em>p</em><sub><em>i</em><em>n</em></sub></span> and <span class="math inline"><em>p</em><sub><em>o</em><em>u</em><em>t</em></sub></span> we define the <em>potential</em> as <span class="math inline"><em>p</em>(<em>v</em>)=<em>m</em><em>i</em><em>n</em>(<em>p</em><sub><em>i</em><em>n</em></sub>(<em>v</em>),<em>p</em><sub><em>o</em><em>u</em><em>t</em></sub>(<em>v</em>))</span>. We call a node <span class="math inline"><em>r</em></span> a <em>reference node</em> if <span class="math inline">$p(r) = min\\{p(v)\\}$</span>. Consider a reference node <span class="math inline"><em>r</em></span>. We claim that the flow can be increased by <span class="math inline"><em>p</em>(<em>r</em>)</span> in such a way that <span class="math inline"><em>p</em>(<em>r</em>)</span> becomes <span class="math inline">0</span>. It is true because <span class="math inline"><em>L</em></span> is acyclic, so we can push the flow out of <span class="math inline"><em>r</em></span> by outgoing edges and it will reach <span class="math inline"><em>t</em></span> because each node has enough outer potential to push the flow out when it reaches it. Similarly, we can pull the flow from <span class="math inline"><em>s</em></span>. The construction of the blocked flow is based on this fact. On each iteration we find a reference node and push the flow from <span class="math inline"><em>s</em></span> to <span class="math inline"><em>t</em></span> through <span class="math inline"><em>r</em></span>. This process can be simulated by BFS. All completely saturated arcs can be deleted from <span class="math inline"><em>L</em></span> as they won't be used later in this phase anyway. Likewise, all the nodes different from <span class="math inline"><em>s</em></span> and <span class="math inline"><em>t</em></span> without outgoing or incoming arcs can be deleted.</p>
<p>Each phase works in <span class="math inline"><em>O</em>(<em>V</em><sup>2</sup>)</span> because there are at most <span class="math inline"><em>V</em></span> iterations (because at least the chosen reference node is deleted), and on each iteration we delete all the edges we passed through except at most <span class="math inline"><em>V</em></span>. Summing, we get <span class="math inline"><em>O</em>(<em>V</em><sup>2</sup> + <em>E</em>)=<em>O</em>(<em>V</em><sup>2</sup>)</span>. Since there are less than <span class="math inline"><em>V</em></span> phases (see the proof <a href="./graph/dinic.html">here</a>), MPM works in <span class="math inline"><em>O</em>(<em>V</em><sup>3</sup>)</span> total.</p>
<h2 id="implementation">Implementation</h2>
<p><code>cpp mpm struct MPM{     struct FlowEdge{         int v, u;         long long cap, flow;         FlowEdge(){}         FlowEdge(int _v, int _u, long long _cap, long long _flow)             : v(_v), u(_u), cap(_cap), flow(_flow){}         FlowEdge(int _v, int _u, long long _cap)             : v(_v), u(_u), cap(_cap), flow(0ll){}     };     const long long flow_inf = 1e18;     vector&lt;FlowEdge&gt; edges;     vector&lt;char&gt; alive;     vector&lt;long long&gt; pin, pout;     vector&lt;list&lt;int&gt; &gt; in, out;     vector&lt;vector&lt;int&gt; &gt; adj;     vector&lt;long long&gt; ex;     int n, m = 0;     int s, t;     vector&lt;int&gt; level;     vector&lt;int&gt; q;     int qh, qt;     void resize(int _n){         n = _n;         ex.resize(n);         q.resize(n);         pin.resize(n);         pout.resize(n);         adj.resize(n);         level.resize(n);         in.resize(n);         out.resize(n);     }     MPM(){}     MPM(int _n, int _s, int _t){resize(_n); s = _s; t = _t;}     void add_edge(int v, int u, long long cap){         edges.push_back(FlowEdge(v, u, cap));         edges.push_back(FlowEdge(u, v, 0));         adj[v].push_back(m);         adj[u].push_back(m + 1);         m += 2;     }     bool bfs(){         while(qh &lt; qt){             int v = q[qh++];             for(int id : adj[v]){                 if(edges[id].cap - edges[id].flow &lt; 1)continue;                 if(level[edges[id].u] != -1)continue;                 level[edges[id].u] = level[v] + 1;                 q[qt++] = edges[id].u;             }         }         return level[t] != -1;     }     long long pot(int v){         return min(pin[v], pout[v]);     }     void remove_node(int v){         for(int i : in[v]){             int u = edges[i].v;             auto it = find(out[u].begin(), out[u].end(), i);             out[u].erase(it);             pout[u] -= edges[i].cap - edges[i].flow;         }         for(int i : out[v]){             int u = edges[i].u;             auto it = find(in[u].begin(), in[u].end(), i);             in[u].erase(it);             pin[u] -= edges[i].cap - edges[i].flow;         }     }     void push(int from, int to, long long f, bool forw){         qh = qt = 0;         ex.assign(n, 0);         ex[from] = f;         q[qt++] = from;         while(qh &lt; qt){             int v = q[qh++];             if(v == to)                 break;             long long must = ex[v];             auto it = forw ? out[v].begin() : in[v].begin();             while(true){                 int u = forw ? edges[*it].u : edges[*it].v;                 long long pushed = min(must, edges[*it].cap - edges[*it].flow);                 if(pushed == 0)break;                 if(forw){                     pout[v] -= pushed;                     pin[u] -= pushed;                 }                 else{                     pin[v] -= pushed;                     pout[u] -= pushed;                 }                 if(ex[u] == 0)                     q[qt++] = u;                 ex[u] += pushed;                 edges[*it].flow += pushed;                 edges[(*it)^1].flow -= pushed;                 must -= pushed;                 if(edges[*it].cap - edges[*it].flow == 0){                     auto jt = it;                     ++jt;                     if(forw){                         in[u].erase(find(in[u].begin(), in[u].end(), *it));                         out[v].erase(it);                     }                     else{                         out[u].erase(find(out[u].begin(), out[u].end(), *it));                         in[v].erase(it);                     }                     it = jt;                 }                 else break;                 if(!must)break;             }         }     }     long long flow(){         long long ans = 0;         while(true){             pin.assign(n, 0);             pout.assign(n, 0);             level.assign(n, -1);             alive.assign(n, true);             level[s] = 0;             qh = 0; qt = 1;             q[0] = s;             if(!bfs())                 break;             for(int i = 0; i &lt; n; i++){                 out[i].clear();                 in[i].clear();             }             for(int i = 0; i &lt; m; i++){                 if(edges[i].cap - edges[i].flow == 0)                     continue;                 int v = edges[i].v, u = edges[i].u;                 if(level[v] + 1 == level[u] &amp;&amp; (level[u] &lt; level[t] || u == t)){                     in[u].push_back(i);                     out[v].push_back(i);                     pin[u] += edges[i].cap - edges[i].flow;                     pout[v] += edges[i].cap - edges[i].flow;                 }             }             pin[s] = pout[t] = flow_inf;             while(true){                 int v = -1;                 for(int i = 0; i &lt; n; i++){                     if(!alive[i])continue;                     if(v == -1 || pot(i) &lt; pot(v))                         v = i;                 }                 if(v == -1)                     break;                 if(pot(v) == 0){                     alive[v] = false;                     remove_node(v);                     continue;                 }                 long long f = pot(v);                 ans += f;                 push(v, s, f, false);                 push(v, t, f, true);                 alive[v] = false;                 remove_node(v);             }         }         return ans;     } };</code></p>
</body>
</html>
