<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<!--?title Number of paths with fixed length. Shortest Path of fixed length. -->
<h1 id="number-of-paths-of-fixed-length-shortest-paths-of-fixed-length">Number of paths of fixed length / Shortest paths of fixed length</h1>
<p>The following article describes solutions to these two problems built on the same idea: reduce the problem to the construction of matrix and compute the solution with the usual matrix multiplication or with a modified multiplication.</p>
<h2 id="number-of-paths-of-a-fixed-length">Number of paths of a fixed length</h2>
<p>We are given a directed, unweighted graph <span class="math inline"><em>G</em></span> with <span class="math inline"><em>n</em></span> vertices and we are given an integer <span class="math inline"><em>k</em></span>. The task is the following: for each pair of vertices <span class="math inline">(<em>i</em>, <em>j</em>)</span> we have to find the number of paths of length <span class="math inline"><em>k</em></span> between these vertices. Paths don't have to be simple, i.e. vertices and edges can be visited any number of times in a single path.</p>
<p>We assume that the graph is specified with an adjacency matrix, i.e. the matrix <span class="math inline"><em>G</em>[][]</span> of size <span class="math inline"><em>n</em> × <em>n</em></span>, where each element <span class="math inline"><em>G</em>[<em>i</em>][<em>j</em>]</span> equal to <span class="math inline">1</span> if the vertex <span class="math inline"><em>i</em></span> is connected with <span class="math inline"><em>j</em></span> by an edge, and <span class="math inline">0</span> is they are not connected by an edge. The following algorithm works also in the case of multiple edges: if some pair of vertices <span class="math inline">(<em>i</em>, <em>j</em>)</span> is connected with <span class="math inline"><em>m</em></span> edges, then we can record this in the adjacency matrix by setting <span class="math inline"><em>G</em>[<em>i</em>][<em>j</em>]=<em>m</em></span>. Also the algorithm works if the graph contains loops (a loop is an edge that connect a vertex with itself).</p>
<p>It is obvious that the constructed adjacency matrix if the answer to the problem for the case <span class="math inline"><em>k</em> = 1</span>. It contains the number of paths of length <span class="math inline">1</span> between each pair of vertices.</p>
<p>We will build the solution iteratively: Lets assume we know the answer for some <span class="math inline"><em>k</em></span>. Here we describe a method how we can construct the answer for <span class="math inline"><em>k</em> + 1</span>. Denote by <span class="math inline"><em>C</em><sub><em>k</em></sub></span> the matrix for the case <span class="math inline"><em>k</em></span>, and by <span class="math inline"><em>C</em><sub><em>k</em> + 1</sub></span> the matrix we want to construct. With the following formula we can compute every entry of <span class="math inline"><em>C</em><sub><em>k</em> + 1</sub></span>: <br /><span class="math display">$$C_{k+1}[i][j] = \sum_{p = 1}^{n} C_k[i][p] \cdot G[p][j]$$</span><br /></p>
<p>It is easy to see that the formula computes nothing other than the product of the matrices <span class="math inline"><em>C</em><sub><em>k</em></sub></span> and <span class="math inline"><em>G</em></span>: <br /><span class="math display"><em>C</em><sub><em>k</em> + 1</sub> = <em>C</em><sub><em>k</em></sub> ⋅ <em>G</em></span><br /></p>
<p>Thus the solution of the problem can be represented as follows: <br /><span class="math display">$$C_k = \underbrace{G \cdot G \cdots G}_{k \text{ times}} = G^k$$</span><br /></p>
<p>It remains to note that the matrix products can be raised to a high power efficiently using <a href="./algebra/binary-exp.html">Binary exponentiation</a>. This gives a solution with <span class="math inline"><em>O</em>(<em>n</em><sup>3</sup>log<em>k</em>)</span> complexity.</p>
<h2 id="shortest-paths-of-a-fixed-length">Shortest paths of a fixed length</h2>
<p>We are given a directed weighted graph <span class="math inline"><em>G</em></span> with <span class="math inline"><em>n</em></span> vertices and an integer <span class="math inline"><em>k</em></span>. For each pair of vertices <span class="math inline">(<em>i</em>, <em>j</em>)</span> we have to find the length of the shortest path between <span class="math inline"><em>i</em></span> and <span class="math inline"><em>j</em></span> that consists of exactly <span class="math inline"><em>k</em></span> edges.</p>
<p>We assume that the graph is specified by an adjacency matrix, i.e. via the matrix <span class="math inline"><em>G</em>[][]</span> of size <span class="math inline"><em>n</em> × <em>n</em></span> where each element <span class="math inline"><em>G</em>[<em>i</em>][<em>j</em>]</span> contains the length of the edges from the vertex <span class="math inline"><em>i</em></span> to the vertex <span class="math inline"><em>j</em></span>. If there is no edge between two vertices, then the corresponding element of the matrix will be assigned to infinity <span class="math inline">∞</span>.</p>
<p>It is obvious that in this form the adjacency matrix is the answer to the problem for <span class="math inline"><em>k</em> = 1</span>. It contains the lengths of shortest paths between each pair of vertices, or <span class="math inline">∞</span> if a path consisting of one edge doesn't exist.</p>
<p>Again we can build the solution to the problem iteratively: Let's assume we know the answer for some <span class="math inline"><em>k</em></span>. We show how we can compute the answer for <span class="math inline"><em>k</em> + 1</span>. Let us denote <span class="math inline"><em>L</em><sub><em>k</em></sub></span> the matrix for <span class="math inline"><em>k</em></span> and <span class="math inline"><em>L</em><sub><em>k</em> + 1</sub></span> the matrix we want to build. Then the following formula computes each entry of <span class="math inline"><em>L</em><sub><em>k</em> + 1</sub></span>: <br /><span class="math display"><em>L</em><sub><em>k</em> + 1</sub>[<em>i</em>][<em>j</em>]=min<sub><em>p</em> = 1…<em>n</em></sub>(<em>L</em><sub><em>k</em></sub>[<em>i</em>][<em>p</em>]+<em>G</em>[<em>p</em>][<em>j</em>])</span><br /></p>
<p>When looking closer at this formula, we can draw an analogy with the matrix multiplication: in fact the matrix <span class="math inline"><em>L</em><sub><em>k</em></sub></span> is multiplied by the matrix <span class="math inline"><em>G</em></span>, the only difference is that instead in the multiplication operation we take the minimum instead of the sum. <br /><span class="math display"><em>L</em><sub><em>k</em> + 1</sub> = <em>L</em><sub><em>k</em></sub> ⊙ <em>G</em>,</span><br /> where the operation <span class="math inline">⊙</span> is defined as follows: <br /><span class="math display"><em>A</em> ⊙ <em>B</em> = <em>C</em>   ⇔   <em>C</em><sub><em>i</em><em>j</em></sub> = min<sub><em>p</em> = 1…<em>n</em></sub>(<em>A</em><sub><em>i</em><em>p</em></sub>+<em>B</em><sub><em>p</em><em>j</em></sub>)</span><br /></p>
<p>Thus the solution of the task can be represented using the modified multiplication: <br /><span class="math display">$$L_k = \underbrace{G \odot \ldots \odot G}_{k~\text{times}} = G^{\odot k}$$</span><br /></p>
<p>It remains to note that we also also can compute this exponentiation efficiently with <a href="./algebra/binary-exp.html">Binary exponentiation</a>, because the modified multiplication is obviously associative. So also this solution has <span class="math inline"><em>O</em>(<em>n</em><sup>3</sup>log<em>k</em>)</span> complexity.</p>
<h2 id="generalization-of-the-problems-for-paths-with-length-up-to-k">Generalization of the problems for paths with length up to <span class="math inline"><em>k</em></span></h2>
<p>The above solutions solve the problems for a fixed <span class="math inline"><em>k</em></span>. However the solutions can be adapted for solving problems for which the paths are allowed to contain no more than <span class="math inline"><em>k</em></span> edges.</p>
<p>This can be done by slightly modifying the input graph.</p>
<p>We duplicate each vertex: for each vertex <span class="math inline"><em>v</em></span> we create one more vertex <span class="math inline"><em>v</em>′</span> and add the edge <span class="math inline">(<em>v</em>, <em>v</em>′)</span> and the loop <span class="math inline">(<em>v</em>′,<em>v</em>′)</span>. The number of paths between <span class="math inline"><em>i</em></span> and <span class="math inline"><em>j</em></span> with at most <span class="math inline"><em>k</em></span> edges is the same number as the number of paths between <span class="math inline"><em>i</em></span> and <span class="math inline"><em>j</em>′</span> with exactly <span class="math inline"><em>k</em> + 1</span> edges, since there is a bijection that maps every path <span class="math inline">[<em>p</em><sub>0</sub> = <em>i</em>,  <em>p</em><sub>1</sub>,  …, <em>p</em><sub><em>m</em> − 1</sub>,  <em>p</em><sub><em>m</em></sub> = <em>j</em>]</span> of length <span class="math inline"><em>m</em> ≤ <em>k</em></span> to the path <span class="math inline">[<em>p</em><sub>0</sub> = <em>i</em>,  <em>p</em><sub>1</sub>,  …, <em>p</em><sub><em>m</em> − 1</sub>,  <em>p</em><sub><em>m</em></sub> = <em>j</em>, <em>j</em>′,…,<em>j</em>′]</span> of length <span class="math inline"><em>k</em> + 1</span>.</p>
<p>The same trick can be applied to compute the shortest paths with at most <span class="math inline"><em>k</em></span> edges. We again duplicate each vertex and add the two mentioned edges with weight <span class="math inline">0</span>.</p>
</body>
</html>
