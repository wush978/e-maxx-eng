<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<!--?title Burnside's lemma / Pólya enumeration theorem -->
<h1 id="burnsides-lemma-pólya-enumeration-theorem">Burnside's lemma / Pólya enumeration theorem</h1>
<h2 id="burnsides-lemma">Burnside's lemma</h2>
<p><strong>Burnside's lemma</strong> was formulated and proven by <strong>Burnside</strong> in 1897, but historically it was already discovered in 1887 by <strong>Frobenius</strong>, and even earlier in 1845 by <strong>Cauchy</strong>. Therefore is is also sometimes named the <strong>Cauchy-Frobenius lemma</strong>.</p>
<p>Burnside's lemma allows us to count the number of equivalence classes in sets, based on internal symmetry.</p>
<h3 id="objects-and-representations">Objects and representations</h3>
<p>We have to clearly distinguish between the number of objects and the number of representations.</p>
<p>Different representations can correspond to the same objects, but of course any representation corresponds to exactly one object. Consequently the set of all representations is divided into equivalence classes. Our task is to compute the number of objects, of equivalently, the number of equivalence classes. The following example will make the difference between object and representation clearer.</p>
<h3 id="example-coloring-of-binary-trees">Example: coloring of binary trees</h3>
<p>Suppose we have the following problem. We have to count the number of ways to color a rooted binary tree with <span class="math inline"><em>n</em></span> vertices with two colors, where at each vertex we do not distinguish between the left and the right children.</p>
<p>Here the set of objects is the set of different colorings of the tree.</p>
<p>We now define the set of representations. A representation of a coloring is a function <span class="math inline"><em>f</em>(<em>v</em>)</span>, which assigns each vertex a color (here we use the colors <span class="math inline">0</span> and <span class="math inline">1</span>). The set of representations is the set containing all possible functions of this kind, and its size is obviously equal to <span class="math inline">2<sup><em>n</em></sup></span>.</p>
<p>At the same time we introduce a partition of this set into equivalence classes.</p>
<p>For example, suppose <span class="math inline"><em>n</em> = 3</span>, and the tree consists of the root <span class="math inline">1</span> and its two children <span class="math inline">2</span> and <span class="math inline">3</span>. Then the following functions <span class="math inline"><em>f</em><sub>1</sub></span> and <span class="math inline"><em>f</em><sub>2</sub></span> are considered equivalent. <br /><span class="math display">$$\begin{array}{ll}f_1(1) = 0 &amp; f_2(1) = 0\\\\
f_1(2) = 1 &amp; f_2(2) = 0\\\\
f_1(3) = 0 &amp; f_2(3) = 1
\end{array}$$</span><br /></p>
<h3 id="invariant-permutations">Invariant permutations</h3>
<p>Why do these two function <span class="math inline"><em>f</em><sub>1</sub></span> and <span class="math inline"><em>f</em><sub>2</sub></span> belong to the same equivalence class? Intuitively this is understandable - we can rearrange the children of vertex <span class="math inline">1</span>, the vertices <span class="math inline">2</span> and <span class="math inline">3</span>, and after such a transformation of the function <span class="math inline"><em>f</em><sub>1</sub></span> it will coincide with <span class="math inline"><em>f</em><sub>2</sub></span>.</p>
<p>But formally this means that there exists an <strong>invariant permutation</strong> <span class="math inline"><em>π</em></span> (i.e. a permutation which does not change the object itself, but only its representation), such that: <br /><span class="math display"><em>f</em><sub>2</sub><em>π</em> ≡ <em>f</em><sub>1</sub></span><br /></p>
<p>So starting from the definition of objects, we can find all the invariant permutations, i.e. all permutations which do not change the object when applying the permutation to the representation. Then we can check whether two functions <span class="math inline"><em>f</em><sub>1</sub></span> and <span class="math inline"><em>f</em><sub>2</sub></span> are equivalent (i.e. if they correspond to the same object) by checking the condition <span class="math inline"><em>f</em><sub>2</sub><em>π</em> ≡ <em>f</em><sub>1</sub></span> for each invariant permutation (or equivalently <span class="math inline"><em>f</em><sub>1</sub><em>π</em> ≡ <em>f</em><sub>2</sub></span>). If at least one permutation is found for which the condition is satisfied, then <span class="math inline"><em>f</em><sub>1</sub></span> and <span class="math inline"><em>f</em><sub>2</sub></span> are equivalent, otherwise they are not equivalent.</p>
<p>Finding all such invariant permutations with respect to the object definition is a key step for the application of both Burnside's lemma and the Pólya enumeration theorem. It is clear that these invariant permutations depend on the specific problem, and their finding is a purely heuristic process based on intuitive considerations. However in most cases it is sufficient to manually find several &quot;basic&quot; permutations, with which all other permutations can be generated (and this part of the work can be shifted to a computer).</p>
<p>It is not difficult to understand that invariant permutations form a <strong>group</strong>, since the product (composition) of invariant permutations is again an invariant permutation. We denote the <strong>group of invariant permutations</strong> by <span class="math inline"><em>G</em></span>.</p>
<h3 id="the-statement-of-the-lemma">The statement of the lemma</h3>
<p>For the formulation of the lemma we need one more definition from algebra. A <strong>fixed point</strong> <span class="math inline"><em>f</em></span> for a permutation <span class="math inline"><em>π</em></span> is an element that is invariant under this permutation: <span class="math inline"><em>f</em> ≡ <em>f</em><em>π</em></span>. For example in out example the fixed points are those functions <span class="math inline"><em>f</em></span>, which correspond to colorings that do not change when the permutation <span class="math inline"><em>π</em></span> is applied to them (i.e. they do not change in the formal sense of the equality of functions). We denote by <span class="math inline"><em>I</em>(<em>π</em>)</span> the <strong>number of fixed points</strong> for the permutation <span class="math inline"><em>π</em></span>.</p>
<p>Then <strong>Burnside's lemma</strong> goes as follows: the number of equivalence classes is equal to the sum of the numbers of fixed points with respect to all permutations from the group <span class="math inline"><em>G</em></span>, divided by the size of this group: <br /><span class="math display">$$|\text{Classes}| = \frac{1}{|G|} \sum_{\pi \in G} I(\pi)$$</span><br /></p>
<p>Although Burnside's lemma itself is not so convenient to use in practice (it is unclear how to quickly look for the value <span class="math inline"><em>I</em>(<em>π</em>)</span>, it most clearly reveals the mathematical essence on which the idea of calculating equivalence classes is based.</p>
<h3 id="proof-of-burnsides-lemma">Proof of Burnside's lemma</h3>
<p>The proof of Burnside's lemma described here is not important for the practical applications, so it can be skipped on the first reading.</p>
<p>The proof here is the simplest known, and does not use group theory. The proof was published by Kenneth P. Bogart in 1991.</p>
<p>We need to prove the following statement: <br /><span class="math display">|Classes|⋅|<em>G</em>|=∑<sub><em>π</em> ∈ <em>G</em></sub><em>I</em>(<em>π</em>)</span><br /></p>
<p>The value on the right side is nothing more the the number of &quot;invariant pairs&quot; <span class="math inline">(<em>f</em>, <em>π</em>)</span>, i.e. pairs such that <span class="math inline"><em>f</em><em>π</em> ≡ <em>f</em></span>. It is obvious that we can change the order of summation. We let the sum iterate over all elements <span class="math inline"><em>f</em></span> and sum over the values <span class="math inline"><em>J</em>(<em>f</em>)</span> - the number of permutations for which <span class="math inline"><em>f</em></span> is a fixed point. <br /><span class="math display">|Classes|⋅|<em>G</em>|=∑<sub><em>f</em></sub><em>J</em>(<em>f</em>)</span><br /></p>
<p>To prove this formula we will compose a table with columns labeled with all functions <span class="math inline"><em>f</em><sub><em>i</em></sub></span> and rows labeled with all permutations <span class="math inline"><em>π</em><sub><em>j</em></sub></span>. And we fill the cells with <span class="math inline"><em>f</em><sub><em>i</em></sub><em>π</em><sub><em>j</em></sub></span>. If we look at the columns in this table as sets, then some of them will coincide, and this means that the corresponding functions <span class="math inline"><em>f</em></span> for these columns are also equivalent. Thus the numbers of different (as sets) columns is equal to the number of classes. Incidentally, from the standpoint of group theory, the column labeled with <span class="math inline"><em>f</em><sub><em>i</em></sub></span> is the orbit of this element. For equivalent elements the orbits coincides, and the number of orbits gives exactly the number of classes.</p>
<p>Thus the columns of the table decompose into equivalence classes. Let us fix a class, and look at the columns in it. First, note that these columns can only contain elements <span class="math inline"><em>f</em><sub><em>i</em></sub></span> of the equivalence class (otherwise some permutation <span class="math inline"><em>π</em><sub><em>j</em></sub></span> moved one of the functions into a different equivalence class, which is impossible since we only look at invariant permutations). Secondly each element <span class="math inline"><em>f</em><sub><em>i</em></sub></span> will occur the same number of times in each columns (this also follows from the fact that the columns correspond to equivalent elements). From this we can conclude, that all the columns within the same equivalence class coincide with each other as multisets.</p>
<p>Now fix an arbitrary element <span class="math inline"><em>f</em></span>. On the one hand, it occurs in its column exactly <span class="math inline"><em>J</em>(<em>f</em>)</span> times (by definition). On the other hand, all columns within the same equivalence class are the same as multisets. Therefore within each column of a given equivalence class any element <span class="math inline"><em>g</em></span> occurs exactly <span class="math inline"><em>J</em>(<em>g</em>)</span> times.</p>
<p>Thus if we arbitrarily take one column from each equivalence class, and sum the number of elements in them, we obtain on one hand <span class="math inline">|Classes|⋅|<em>G</em>|</span> (simply by multiplying the number of columns by the number of rows), and on the other hand the sum of the quantities <span class="math inline"><em>J</em>(<em>f</em>)</span> for all <span class="math inline"><em>f</em></span> (this follows from all the previous arguments): <br /><span class="math display">|Classes|⋅|<em>G</em>|=∑<sub><em>f</em></sub><em>J</em>(<em>f</em>)</span><br /></p>
<h2 id="pólya-enumeration-theorem">Pólya enumeration theorem</h2>
<p>The Pólya enumeration theorem is a generalization of Burnside's lemma, and it also provides a more convenient tool for finding the number of equivalence classes. It should noted that this theorem was already discovered before Pólya by Redfield in 1927, but his publication went unnoticed by mathematicians. Pólya independently came to the same results in 1937, and his publication was more successful.</p>
<p>Here we discuss only a special case of the Pólya enumeration theorem, which will turn out very useful in practice. The general formula of the theorem will not be discussed.</p>
<p>We denote by <span class="math inline"><em>C</em>(<em>π</em>)</span> the number of cycles in the permutation <span class="math inline"><em>π</em></span>. Then the following formula (a <strong>special case of the Pólya enumeration theorem</strong>) holds: <br /><span class="math display">$$|\text{Classes}| = \frac{1}{|G|} \sum_{\pi \in G} k^{C(\pi)}$$</span><br /> <span class="math inline"><em>k</em></span> is the number of values that each representation element can take, in the case of the coloring of a binary tree this would be <span class="math inline"><em>k</em> = 2</span>.</p>
<h3 id="evidence">Evidence</h3>
<p>This formula is a direct consequence of Burnside's lemma. To get it, we just need to find an explicit expression for <span class="math inline"><em>I</em>(<em>π</em>)</span>, which appears in the lemma. Recall, that <span class="math inline"><em>I</em>(<em>π</em>)</span> is the number of fixed points in the permutation <span class="math inline"><em>π</em></span>.</p>
<p>Thus we consider a permutation <span class="math inline"><em>π</em></span> and some element <span class="math inline"><em>f</em></span>. During the application of <span class="math inline"><em>π</em></span>, the elements in <span class="math inline"><em>f</em></span> move via the cycles in the permutation. Since the result should obtain <span class="math inline"><em>f</em> ≡ <em>f</em><em>π</em></span>, the elements touched by one cycle must all be equal. At the same time different cycles are independent. Thus for each permutation cycle <span class="math inline"><em>π</em></span> we can choose one value (among <span class="math inline"><em>k</em></span> possible) and thus we get the number of fixed points: <br /><span class="math display"><em>I</em>(<em>π</em>)=<em>k</em><sup><em>C</em>(<em>π</em>)</sup></span><br /></p>
<h2 id="application-coloring-necklaces">Application: Coloring necklaces</h2>
<p>The problem &quot;Necklace&quot; is one of the classical combinatorial problems. The task is to count the number of different necklaces from <span class="math inline"><em>n</em></span> beads, each of which can be painted in one of the <span class="math inline"><em>k</em></span> colors. When comparing two necklaces, they can be rotated, but not reversed (i.e. a cyclic shift is permitted).</p>
<p>In this problem we can immediately find the group of invariant permutations: <br /><span class="math display">$$\begin{align}
\pi_0 &amp;= 1 2 3 \dots n\\\\
\pi_1 &amp;= 2 3 \dots n 1\\\\
\pi_2 &amp;= 3 \dots n 12\\\\
&amp;\dots\\\\
\pi_{n-1} &amp;= n 1 2 3\dots\end{align}$$</span><br /></p>
<p>Let us find an explicit formula for calculating <span class="math inline"><em>C</em>(<em>π</em><sub><em>i</em></sub>)</span>. First we note, that that the permutation <span class="math inline"><em>π</em><sub><em>i</em></sub></span> has at the <span class="math inline"><em>j</em></span>-th position the value <span class="math inline"><em>i</em> + <em>j</em></span> (taken modulo <span class="math inline"><em>n</em></span>). If we check the cycle structure for <span class="math inline"><em>π</em><sub><em>i</em></sub></span>. We see that <span class="math inline">1</span> goes to <span class="math inline">1 + <em>i</em></span>, <span class="math inline">1 + <em>i</em></span> goes to <span class="math inline">1 + 2<em>i</em></span>, which goes to <span class="math inline">1 + 3<em>i</em></span>, etc., until we come to a number of the form <span class="math inline">1 + <em>k</em><em>n</em></span>. Similar statements can be mode for the remaining elements. Hence we see that all cycles have the same length, namely <span class="math inline">$\frac{\\text{lcm}(i, n)}{i} = \frac{n}{\gcd(i, n)}$</span>. Thus the number of cycles in <span class="math inline"><em>π</em><sub><em>i</em></sub></span> will be equal to <span class="math inline">gcd(<em>i</em>, <em>n</em>)</span>.</p>
<p>Substituting these values into the Pólya enumeration theorem, we obtain the solution: <br /><span class="math display">$$\frac{1}{n} \sum_{i=1}^n k^{\gcd(i, n)}$$</span><br /></p>
<p>You can leave this formula in this form, or you can simplify it even more. Let transfer the sum so that it iterates over all divisors of <span class="math inline"><em>n</em></span>. In the original sum there will be many equivalent terms: if <span class="math inline"><em>i</em></span> is not a divisor of <span class="math inline"><em>n</em></span>, then such a divisor can be found after computing <span class="math inline">gcd(<em>i</em>, <em>n</em>)</span>. Therefore for each divisor <span class="math inline"><em>d</em> | <em>n</em></span> its term <span class="math inline"><em>k</em><sup>gcd(<em>d</em>, <em>n</em>)</sup> = <em>k</em><sup><em>d</em></sup></span> will appear in the sum multiple times, i.e. the answer to the problem can be rewritten as <br /><span class="math display">$$\frac{1}{n} \sum_{d ~|~ n} C_d k^d,$$</span><br /> where <span class="math inline"><em>C</em><sub><em>d</em></sub></span> is the number of such numbers <span class="math inline"><em>i</em></span> with <span class="math inline">gcd(<em>i</em>, <em>n</em>)=<em>d</em></span>. We can find an explicit expression for this value. Any such number <span class="math inline"><em>i</em></span> has the form <span class="math inline"><em>i</em> = <em>d</em><em>j</em></span> with <span class="math inline">gcd(<em>j</em>, <em>n</em>/<em>d</em>)=1</span> (otherwise <span class="math inline">gcd(<em>i</em>, <em>n</em>)&gt;<em>d</em></span>). So we can count the number of <span class="math inline"><em>j</em></span> with this behavior. <a href="./algebra/phi-function.html">Euler's phi function</a> gives us the result <span class="math inline"><em>C</em><sub><em>d</em></sub> = <em>ϕ</em>(<em>n</em>/<em>d</em>)</span>, and therefore we get the answer: <br /><span class="math display">$$\frac{1}{n} \sum_{d ~|~ n} \phi\left(\frac{n}{d}\right) k^d$$</span><br /></p>
<h2 id="application-coloring-a-torus">Application: Coloring a torus</h2>
<p>Quite often we cannot obtain an explicit formula for the number of equivalence classes. In many problems the number of permutations in a group can be too large for manual calculations and it is not possible to compute analytically the number of cycles in them.</p>
<p>In that case we should manually find several &quot;basic&quot; permutations, so that they can generate the entire group <span class="math inline"><em>G</em></span>. Next we can write a program that will generate all permutations of the group <span class="math inline"><em>G</em></span>, count the number of cycles in them, and compute the answer with the formula.</p>
<p>Consider the example of the problem for coloring a torus. There is a checkered sheet of paper <span class="math inline"><em>n</em> × <em>m</em></span> (<span class="math inline"><em>n</em> &lt; <em>m</em></span>), some of the cells are black. Then a cylinder is obtained from this sheet by gluing together the two sides with lengths <span class="math inline"><em>m</em></span>. Then a torus is obtained from the cylinder by gluing together the two circles (top and bottom) without twisting. The task is to compute the number of different colored tori, assuming that we cannot see the glued lines, and the torus can be turned and turned.</p>
<p>We again start with a piece of <span class="math inline"><em>n</em> × <em>m</em></span> paper. It is easy to see that the following types of transformations preserve the equivalence class: a cyclic shift of the rows, a cyclic shift of the columns, and a rotation of the sheet by 180 degrees. It is also easy to see, that these transformations can generate the entire group of invariant transformations. If we somehow number the cells of the paper, then we can write three permutations <span class="math inline"><em>p</em><sub>1</sub></span>, <span class="math inline"><em>p</em><sub>2</sub></span>, <span class="math inline"><em>p</em><sub>3</sub></span> corresponding to these types of transformation.</p>
<p>Next it only remains to generate all permutations obtained as a product. It is obvious that all such permutations have the form <span class="math inline"><em>p</em><sub>1</sub><sup><em>i</em><sub>1</sub></sup><em>p</em><sub>2</sub><sup><em>i</em><sub>2</sub></sup><em>p</em><sub>3</sub><sup><em>i</em><sub>3</sub></sup></span> where <span class="math inline"><em>i</em><sub>1</sub> = 0…<em>m</em> − 1</span>, <span class="math inline"><em>i</em><sub>2</sub> = 0…<em>n</em> − 1</span>, <span class="math inline"><em>i</em><sub>3</sub> = 0…1</span>.</p>
<p>Thus we can write the implementations to this problem.</p>
<p>```cpp burnside_tori using Permutation = vector<int>;</p>
<p>void operator*=(Permutation&amp; p, Permutation const&amp; q) { Permutation copy = p; for (int i = 0; i &lt; p.size(); i++) p[i] = copy[q[i]]; }</p>
<p>int count_cycles(Permutation p) { int cnt = 0; for (int i = 0; i &lt; p.size(); i++) { if (p[i] != -1) { cnt++; for (int j = i; p[j] != -1;) { int next = p[j]; p[j] = -1; j = next; } } } return cnt; }</p>
<p>int solve(int n, int m) { Permutation p(n<em>m), p1(n</em>m), p2(n<em>m), p3(n</em>m); for (int i = 0; i &lt; n<em>m; i++) { p[i] = i; p1[i] = (i % n + 1) % n + i / n </em> n; p2[i] = (i / n + 1) % m * n + i % n; p3[i] = (m - 1 - i / n) * n + (n - 1 - i % n); }</p>
<pre><code>set&lt;Permutation&gt; s;
for (int i1 = 0; i1 &lt; n; i1++) {
    for (int i2 = 0; i2 &lt; m; i2++) {
        for (int i3 = 0; i3 &lt; 2; i3++) {
            s.insert(p);
            p *= p3;
        }
        p *= p2;
    }
    p *= p1;
}

int sum = 0;
for (Permutation const&amp; p : s) {
    sum += 1 &lt;&lt; count_cycles(p);
}
return sum / s.size();</code></pre>
<p>} ```</p>
</body>
</html>
