<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<!--?title Basic Geometry -->
<h1 id="basic-geometry">Basic Geometry</h1>
<p>In this article we will consider basic operations on points in Euclidean space which maintains the foundation of the whole analytical geometry. We will consider for each point <span class="math inline">$\mathbf r$</span> the vector <span class="math inline">$\vec{\mathbf r}$</span> directed from <span class="math inline">$\mathbf 0$</span> to <span class="math inline">$\mathbf r$</span>. Later we will not distinguish between <span class="math inline">$\mathbf r$</span> and <span class="math inline">$\vec{\mathbf r}$</span> and use the term <strong>point</strong> as a synonym for <strong>vector</strong>.</p>
<h2 id="linear-operations">Linear operations</h2>
<p>Both 2D and 3D points maintain linear space, which means that for them sum of points and multiplication of point by some number are defined. Here are those basic implementations for 2D:</p>
<p><code>cpp point2d struct point2d {     ftype x, y;     point2d() {}     point2d(ftype x, ftype y): x(x), y(y) {}     point2d&amp; operator+=(const point2d &amp;t) {         x += t.x;         y += t.y;         return *this;     }     point2d&amp; operator-=(const point2d &amp;t) {         x -= t.x;         y -= t.y;         return *this;     }     point2d&amp; operator*=(ftype t) {         x *= t;         y *= t;         return *this;     }     point2d&amp; operator/=(ftype t) {         x /= t;         y /= t;         return *this;     }     point2d operator+(const point2d &amp;t) const {         return point2d(*this) += t;     }     point2d operator-(const point2d &amp;t) const {         return point2d(*this) -= t;     }     point2d operator*(ftype t) const {         return point2d(*this) *= t;     }     point2d operator/(ftype t) const {         return point2d(*this) /= t;     } }; point2d operator*(ftype a, point2d b) {     return b * a; }</code> And 3D points: <code>cpp point3d struct point3d {     ftype x, y, z;     point3d() {}     point3d(ftype x, ftype y, ftype z): x(x), y(y), z(z) {}     point3d&amp; operator+=(const point3d &amp;t) {         x += t.x;         y += t.y;         z += t.z;         return *this;     }     point3d&amp; operator-=(const point3d &amp;t) {         x -= t.x;         y -= t.y;         z -= t.z;         return *this;     }     point3d&amp; operator*=(ftype t) {         x *= t;         y *= t;         z *= t;         return *this;     }     point3d&amp; operator/=(ftype t) {         x /= t;         y /= t;         z /= t;         return *this;     }     point3d operator+(const point3d &amp;t) const {         return point3d(*this) += t;     }     point3d operator-(const point3d &amp;t) const {         return point3d(*this) -= t;     }     point3d operator*(ftype t) const {         return point3d(*this) *= t;     }     point3d operator/(ftype t) const {         return point3d(*this) /= t;     } }; point3d operator*(ftype a, point3d b) {     return b * a; }</code></p>
<p>Here <code>ftype</code> is some type used for coordinates, usually <code>int</code>, <code>double</code> or <code>long long</code>.</p>
<h2 id="dot-product">Dot product</h2>
<h3 id="definition">Definition</h3>
<p>The dot (or scalar) product <span class="math inline">$\mathbf a \cdot \mathbf b$</span> for vectors <span class="math inline">$\mathbf a$</span> and <span class="math inline">$\mathbf b$</span> can be defined in two identical ways. Geometrically it is product of the length of the first vector by the length of the projection of the second vector onto the first one. As you may see from the image below this projection is nothing but <span class="math inline">$|\mathbf a| \cos \theta$</span> where <span class="math inline"><em>θ</em></span> is the angle between <span class="math inline">$\mathbf a$</span> and <span class="math inline">$\mathbf b$</span>. Thus <span class="math inline">$\mathbf a\cdot \mathbf b = |\mathbf a| \cos \theta \cdot |\mathbf b|$</span>.</p>
<center>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3e/Dot_Product.svg/300px-Dot_Product.svg.png" />
</center>
<p>The dot product holds some notable properties:</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">$\mathbf a \cdot \mathbf b = \mathbf b \cdot \mathbf a$</span></li>
<li><span class="math inline">$(\alpha \cdot \mathbf a)\cdot \mathbf b = \alpha \cdot (\mathbf a \cdot \mathbf b)$</span></li>
<li><span class="math inline">$(\mathbf a + \mathbf b)\cdot \mathbf c = \mathbf a \cdot \mathbf c + \mathbf b \cdot \mathbf c$</span></li>
</ol>
<p>I.e. it is a commutative function which is linear with respect to both arguments. Let's denote the unit vectors as <br /><span class="math display">$$\mathbf e_x = \begin{pmatrix} 1 \\\ 0 \\\ 0 \end{pmatrix}, \mathbf e_y = \begin{pmatrix} 0 \\\ 1 \\\ 0 \end{pmatrix}, \mathbf e_z = \begin{pmatrix} 0 \\\ 0 \\\ 1 \end{pmatrix}.$$</span><br /> With this notation we can write the vector <span class="math inline">$\mathbf r = (x;y;z)$</span> as <span class="math inline">$r = x \cdot \mathbf e_x + y \cdot \mathbf e_y + z \cdot \mathbf e_z$</span>. And since for unit vectors <br /><span class="math display">$$\mathbf e_x\cdot \mathbf e_x = \mathbf e_y\cdot \mathbf e_y = \mathbf e_z\cdot \mathbf e_z = 1,\\\
\mathbf e_x\cdot \mathbf e_y = \mathbf e_y\cdot \mathbf e_z = \mathbf e_z\cdot \mathbf e_x = 0$$</span><br /> we can see that in terms of coordinates for <span class="math inline">$\mathbf a = (x_1;y_1;z_1)$</span> and <span class="math inline">$\mathbf b = (x_2;y_2;z_2)$</span> holds <br /><span class="math display">$$\mathbf a\cdot \mathbf b = (x_1 \cdot \mathbf e_x + y_1 \cdot\mathbf e_y + z_1 \cdot\mathbf e_z)\cdot( x_2 \cdot\mathbf e_x + y_2 \cdot\mathbf e_y + z_2 \cdot\mathbf e_z) = x_1 x_2 + y_1 y_2 + z_1 z_2$$</span><br /></p>
<p>That is also the algebraic definition of the dot product. From this we can write functions which calculate it.</p>
<p><code>cpp dotproduct ftype dot(point2d a, point2d b) {     return a.x * b.x + a.y * b.y; } ftype dot(point3d a, point3d b) {     return a.x * b.x + a.y * b.y + a.z * b.z; }</code></p>
<p>When solving problems one should use algebraic definition to calculate dot products, but keep in mind geometric definition and properties to use it.</p>
<h3 id="properties">Properties</h3>
<p>We can define many geometrical properties via the dot product. For example</p>
<ol style="list-style-type: decimal">
<li>Norm of <span class="math inline">$\mathbf a$</span> (squared length): <span class="math inline">$|\mathbf a|^2 = \mathbf a\cdot \mathbf a$</span></li>
<li>Length of <span class="math inline">$\mathbf a$</span>: <span class="math inline">$|\mathbf a| = \sqrt{\mathbf a\cdot \mathbf a}$</span></li>
<li>Projection of <span class="math inline">$\mathbf a$</span> onto <span class="math inline">$\mathbf b$</span>: <span class="math inline">$\dfrac{\mathbf a\cdot\mathbf b}{|\mathbf b|}$</span></li>
<li>Angle between vectors: <span class="math inline">$\arccos \left(\dfrac{\mathbf a\cdot \mathbf b}{|\mathbf a| \cdot |\mathbf b|}\right)$</span></li>
<li>From the previous point we may see that the dot product is positive if the angle between them is acute, negative if it is obtuse and it equals zero if they are orthogonal, i.e. they form a right angle.</li>
</ol>
<p>Note that all these functions do not depend on the number of dimensions, hence they will be the same for the 2D and 3D case:</p>
<p><code>cpp dotproperties ftype norm(point2d a) {     return dot(a, a); } double abs(point2d a) {     return sqrt(norm(a)); } double proj(point2d a, point2d b) {     return dot(a, b) / abs(b); } double angle(point2d a, point2d b) {     return acos(dot(a, b) / abs(a) / abs(b)); }</code></p>
<p>To see the next important property we should take a look at the set of points <span class="math inline">$\mathbf r$</span> for which <span class="math inline">$\mathbf r\cdot \mathbf a = C$</span> for some fixed constant <span class="math inline"><em>C</em></span>. You can see that this set of points is exactly the set of points for which the projection onto <span class="math inline">$\mathbf a$</span> is the point <span class="math inline">$C \cdot \dfrac{\mathbf a}{|\mathbf a|}$</span> and they form a hyperplane orthogonal to <span class="math inline">$\mathbf a$</span>. You can see the vector <span class="math inline">$\mathbf a$</span> alongside with several such vectors having same dot product with it in 2D on the picture below:</p>
<center>
<img src="https://i.imgur.com/eyO7St4.png" alt="Vectors having same dot product with a" />
</center>
<p>In 2D these vectors will form a line, in 3D they will form a plane. Note that this result allows us to define a line in 2D as <span class="math inline">$\mathbf r\cdot \mathbf n=C$</span> or <span class="math inline">$(\mathbf r - \mathbf r_0)\cdot \mathbf n=0$</span> where <span class="math inline">$\mathbf n$</span> is vector orthogonal to the line and <span class="math inline">$\mathbf r_0$</span> is any vector already present on the line and <span class="math inline">$C = \mathbf r_0\cdot \mathbf n$</span>. In the same manner a plane can be defined in 3D.</p>
<h2 id="cross-product">Cross product</h2>
<h3 id="definition-1">Definition</h3>
Assume you have three vectors <span class="math inline">$\mathbf a$</span>, <span class="math inline">$\mathbf b$</span> and <span class="math inline">$\mathbf c$</span> in 3D space joined in a parallelepiped as in the picture below:
<center>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3e/Parallelepiped_volume.svg/240px-Parallelepiped_volume.svg.png" alt="Three vectors" />
</center>
<p>How would you calculate its volume? From school we know that we should multiply the area of the base with the height, which is projection of <span class="math inline">$\mathbf a$</span> onto direction orthogonal to base. That means that if we define <span class="math inline">$\mathbf b \times \mathbf c$</span> as the vector which is orthogonal to both <span class="math inline">$\mathbf b$</span> and <span class="math inline">$\mathbf c$</span> and which length is equal to the area of the parallelogram formed by <span class="math inline">$\mathbf b$</span> and <span class="math inline">$\mathbf c$</span> then <span class="math inline">$|\mathbf a\cdot (\mathbf b\times\mathbf c)|$</span> will be equal to the volume of the parallelepiped. For integrity we will say that <span class="math inline">$\mathbf b\times \mathbf c$</span> will be always directed in such way that the rotation from the vector <span class="math inline">$\mathbf b$</span> to the vector <span class="math inline">$\mathbf c$</span> from the point of <span class="math inline">$\mathbf b\times \mathbf c$</span> is always counter-clockwise (see the picture below).</p>
<center>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b0/Cross_product_vector.svg/250px-Cross_product_vector.svg.png" alt="cross product" />
</center>
<p>This defines the cross (or vector) product <span class="math inline">$\mathbf b\times \mathbf c$</span> of the vectors <span class="math inline">$\mathbf b$</span> and <span class="math inline">$\mathbf c$</span> and the triple product <span class="math inline">$\mathbf a\cdot(\mathbf b\times \mathbf c)$</span> of the vectors <span class="math inline">$\mathbf a$</span>, <span class="math inline">$\mathbf b$</span> and <span class="math inline">$\mathbf c$</span>.</p>
<p>Some notable properties of cross and triple products:</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">$\mathbf a\times \mathbf b = -\mathbf b\times \mathbf a$</span></li>
<li><span class="math inline">$(\alpha \cdot \mathbf a)\times \mathbf b = \alpha \cdot (\mathbf a\times \mathbf b)$</span></li>
<li>For any <span class="math inline">$\mathbf b$</span> and <span class="math inline">$\mathbf c$</span> there is exactly one vector <span class="math inline">$\mathbf r$</span> such that <span class="math inline">$\mathbf a\cdot (\mathbf b\times \mathbf c) = \mathbf a\cdot\mathbf r$</span> for any vector <span class="math inline">$\mathbf a$</span>. <br>Indeed if there are two such vectors <span class="math inline">$\mathbf r_1$</span> and <span class="math inline">$\mathbf r_2$</span> then <span class="math inline">$\mathbf a\cdot (\mathbf r_1 - \mathbf r_2)=0$</span> for all vectors <span class="math inline">$\mathbf a$</span> which is possible only when <span class="math inline">$\mathbf r_1 = \mathbf r_2$</span>.</li>
<li><span class="math inline">$\mathbf a\cdot (\mathbf b\times \mathbf c) = \mathbf b\cdot (\mathbf c\times \mathbf a) = -\mathbf a\cdot( \mathbf c\times \mathbf b)$</span></li>
<li><span class="math inline">$(\mathbf a + \mathbf b)\times \mathbf c = \mathbf a\times \mathbf c + \mathbf b\times \mathbf c$</span>. Indeed for all vectors <span class="math inline">$\mathbf r$</span> the chain of equations holds: <br /><span class="math display">$$\mathbf r\cdot( (\mathbf a + \mathbf b)\times \mathbf c) = (\mathbf a + \mathbf b) \cdot (\mathbf c\times \mathbf r) =  \mathbf a \cdot(\mathbf c\times \mathbf r) + \mathbf b\cdot(\mathbf c\times \mathbf r) = \mathbf r\cdot (\mathbf a\times \mathbf c) + \mathbf r\cdot(\mathbf b\times \mathbf c) = \mathbf r\cdot(\mathbf a\times \mathbf c + \mathbf b\times \mathbf c)$$</span><br /> Which proves <span class="math inline">$(\mathbf a + \mathbf b)\times \mathbf c = \mathbf a\times \mathbf c + \mathbf b\times \mathbf c$</span> due to point 3.</li>
<li><span class="math inline">$|\mathbf a\times \mathbf b|=|\mathbf a| \cdot |\mathbf b| \sin \theta$</span> where <span class="math inline"><em>θ</em></span> is angle between <span class="math inline">$\mathbf a$</span> and <span class="math inline">$\mathbf b$</span>, since <span class="math inline">$|\mathbf a\times \mathbf b|$</span> equals to the area of the parallelogram formed by <span class="math inline">$\mathbf a$</span> and <span class="math inline">$\mathbf b$</span>.</li>
</ol>
<p>Given all this and that the following equation holds for the unit vectors <br /><span class="math display">$$\mathbf e_x\times \mathbf e_x = \mathbf e_y\times \mathbf e_y = \mathbf e_z\times \mathbf e_z = \mathbf 0,\\\
\mathbf e_x\times \mathbf e_y = \mathbf e_z,~\mathbf e_y\times \mathbf e_z = \mathbf e_x,~\mathbf e_z\times \mathbf e_x = \mathbf e_y$$</span><br /> we can calculate the cross product of <span class="math inline">$\mathbf a = (x_1;y_1;z_1)$</span> and <span class="math inline">$\mathbf b = (x_2;y_2;z_2)$</span> in coordinate form:</p>
<p><br /><span class="math display">$$\mathbf a\times \mathbf b = (x_1 \cdot \mathbf e_x + y_1 \cdot \mathbf e_y + z_1 \cdot \mathbf e_z)\times (x_2 \cdot \mathbf e_x + y_2 \cdot \mathbf e_y + z_2 \cdot \mathbf e_z) =$$</span><br /> <br /><span class="math display">$$(y_1 z_2 - z_1 y_2)\mathbf e_x  + (z_1 x_2 - x_1 z_2)\mathbf e_y + (x_1 y_2 - y_1 x_2)$$</span><br /></p>
<p>Which also can be written in the more elegant form: <br /><span class="math display">$$\mathbf a\times \mathbf b = \begin{vmatrix}\mathbf e_x &amp; \mathbf e_y &amp; \mathbf e_z \\\ x_1 &amp; y_1 &amp; z_1 \\\ x_2 &amp; y_2 &amp; z_2 \end{vmatrix},~a\cdot(b\times c) = \begin{vmatrix} x_1 &amp; y_1 &amp; z_1 \\\ x_2 &amp; y_2 &amp; z_2 \\\ x_3 &amp; y_3 &amp; z_3 \end{vmatrix}$$</span><br /> Here <span class="math inline">| ⋅ |</span> stands for the determinant of a matrix.</p>
<p>Some kind of cross product (namely the pseudo-scalar product) can also be implemented in the 2D case. If we would like to calculate the area of parallelogram formed by vectors <span class="math inline">$\mathbf a$</span> and <span class="math inline">$\mathbf b$</span> we would compute <span class="math inline">$|\mathbf e_z\cdot(\mathbf a\times \mathbf b)| = |x_1 y_2 - y_1 x_2|$</span>. Another way to obtain the same result is to multiply <span class="math inline">$|\mathbf a|$</span> (base of parallelogram) with the height, which is the projection of vector <span class="math inline">$\mathbf b$</span> onto vector <span class="math inline">$\mathbf a$</span> rotated by <span class="math inline">90<sup>∘</sup></span> which in turn is <span class="math inline">$\widehat{\mathbf a}=(-y_1;x_1)$</span>. That is, to calculate <span class="math inline">$|\widehat{\mathbf a}\cdot\mathbf b|=|x_1y_2 - y_1 x_2|$</span>.</p>
<p>If we will take the sign into consideration then the area will be positive if the rotation from <span class="math inline">$\mathbf a$</span> to <span class="math inline">$\mathbf b$</span> (i.e. from the view of the point of <span class="math inline">$\mathbf e_z$</span>) is performed counter-clockwise and negative otherwise. That defines the pseudo-scalar product. Note that it also equals <span class="math inline">$|\mathbf a| \cdot |\mathbf b| \sin \theta$</span> where <span class="math inline"><em>θ</em></span> is angle from <span class="math inline">$\mathbf a$</span> to <span class="math inline">$\mathbf b$</span> count counter-clockwise (and negative if rotation is clockwise).</p>
<p>Let's implement all this stuff!</p>
<p><code>cpp crossproduct point3d cross(point3d a, point3d b) {     return point3d(a.y * b.z - a.z * b.y,                    a.z * b.x - a.x * b.z,                    a.x * b.y - a.y * b.x); } ftype triple(point3d a, point3d b, point3d c) {     return dot(a, cross(b, c)); } ftype cross(point2d a, point2d b) {     return a.x * b.y - a.y * b.x; }</code></p>
<h3 id="properties-1">Properties</h3>
<p>As for the cross product, it equals to the zero vector iff the vectors <span class="math inline">$\mathbf a$</span> and <span class="math inline">$\mathbf b$</span> are collinear (they form a common line, i.e. they are parallel). The same thing holds for the triple product, it is equal to zero iff the vectors <span class="math inline">$\mathbf a$</span>, <span class="math inline">$\mathbf b$</span> and <span class="math inline">$\mathbf c$</span> are coplanar (they form a common plane).</p>
<p>From this we can obtain universal equations defining lines and planes. A line can be defined via its direction vector <span class="math inline">$\mathbf d$</span> and an initial point <span class="math inline">$\mathbf r_0$</span> or by two points <span class="math inline">$\mathbf a$</span> and <span class="math inline">$\mathbf b$</span>. It is defined as <span class="math inline">$(\mathbf r - \mathbf r_0)\times\mathbf d=0$</span> or as <span class="math inline">$(\mathbf r - \mathbf a)\times (\mathbf b - \mathbf a) = 0$</span>. As for planes, it can be defined by three points <span class="math inline">$\mathbf a$</span>, <span class="math inline">$\mathbf b$</span> and <span class="math inline">$\mathbf c$</span> as <span class="math inline">$(\mathbf r - \mathbf a)\cdot((\mathbf b - \mathbf a)\times (\mathbf c - \mathbf a))=0$</span> or by initial point <span class="math inline">$\mathbf r_0$</span> and two direction vectors lying in this plane <span class="math inline">$\mathbf d_1$</span> and <span class="math inline">$\mathbf d_2$</span>: <span class="math inline">$(\mathbf r - \mathbf r_0)\cdot(\mathbf d_1\times \mathbf d_2)=0$</span>.</p>
<p>In 2D the pseudo-scalar product also may be used to check the orientation between two vectors because it is positive if the rotation from the first to the second vector is clockwise and negative otherwise. And, of course, it can be used to calculate areas of polygons, which is described in a different article. A triple product can be used for the same purpose in 3D space.</p>
<h2 id="exercises">Exercises</h2>
<h3 id="line-intersection">Line intersection</h3>
<p>There are many possible ways to define a line in 2D and you shouldn't hesitate to combine them. For example we have two lines and we want to find their intersection points. We can say that all points from first line can be parameterized as <span class="math inline">$\mathbf r = \mathbf a_1 + t \cdot \mathbf d_1$</span> where <span class="math inline">$\mathbf a_1$</span> is initial point, <span class="math inline">$\mathbf d_1$</span> is direction and <span class="math inline"><em>t</em></span> is some real parameter. As for second line all its points must satisfy <span class="math inline">$(\mathbf r - \mathbf a_2)\times \mathbf d_2=0$</span>. From this we can easily find parameter <span class="math inline"><em>t</em></span>:</p>
<p><br /><span class="math display">$$(\mathbf a_1 + t \cdot \mathbf d_1 - \mathbf a_2)\times \mathbf d_2=0 \quad\Rightarrow\quad t = \dfrac{(\mathbf a_2 - \mathbf a_1)\times\mathbf d_2}{\mathbf d_1\times \mathbf d_2}$$</span><br /></p>
<p>Let's implement function to intersect two lines.</p>
<p><code>cpp line_intersection point2d intersect(point2d a1, point2d d1, point2d a2, point2d d2) {     return a1 + cross(a2 - a1, d2) / cross(d1, d2) * d1; }</code></p>
<h3 id="planes-intersection">Planes intersection</h3>
<p>However sometimes it might be hard to use some geometric insights. For example, you're given three planes defined by initial points <span class="math inline">$\mathbf a_i$</span> and directions <span class="math inline">$\mathbf d_i$</span> and you want to find their intersection point. You may note that you just have to solve the system of equations:</p>
<p><br /><span class="math display">$$\begin{cases}\mathbf r\cdot \mathbf n_1 = \mathbf a_1\cdot \mathbf n_1, \\\ \mathbf r\cdot \mathbf n_2 = \mathbf a_2\cdot \mathbf n_2, \\\ \mathbf r\cdot \mathbf n_3 = \mathbf a_3\cdot \mathbf n_3\end{cases}$$</span><br /></p>
<p>Instead of thinking on geometric approach, you can work out an algebraic one which can be obtained immediately. For example, given that you already implemented a point class, it will be easy for you to solve this system using Cramer's rule because the triple product is simply the determinant of the matrix obtained from the vectors being its columns:</p>
<p><code>cpp plane_intersection point3d intersect(point3d a1, point3d n1, point3d a2, point3d n2, point3d a3, point3d n3) {     point3d x(n1.x, n2.x, n3.x);     point3d y(n1.y, n2.y, n3.y);     point3d z(n1.z, n2.z, n3.z);      point3d d(dot(a1, n1), dot(a2, n2), dot(a3, n3));     return point3d(triple(d, y, z),                    triple(x, d, z),                    triple(x, y, d)) / triple(n1, n2, n3); }</code></p>
<p>Now you may try to find out approaches for common geometric operations yourself to get used to all this stuff.</p>
</body>
</html>
