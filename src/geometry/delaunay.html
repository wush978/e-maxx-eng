<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<!--?title Delaunay triangulation and Voronoi diagram -->
<h1 id="delaunay-triangulation-and-voronoi-diagram">Delaunay triangulation and Voronoi diagram</h1>
<p>Consider a set <span class="math inline">$\\{p_i\\}$</span> of points on the plane. A <strong>Voronoi diagram</strong> <span class="math inline">$V(\\{p_i\\})$</span> of <span class="math inline">$\\{p_i\\}$</span> is a partition of the plane into <span class="math inline"><em>n</em></span> regions <span class="math inline"><em>V</em><sub><em>i</em></sub></span>, where <span class="math inline">$V_i = \\{p\in\mathbb{R}^2;\ \rho(p, p_i) = \min\ \rho(p, p_k)\\}$</span>. The cells of the Voronoi diagram are polygons (possibly infinite). A <strong>Delaunay triangulation</strong> <span class="math inline">$D(\\{p_i\\})$</span> of <span class="math inline">$\\{p_i\\}$</span> is a triangulation where every point <span class="math inline"><em>p</em><sub><em>i</em></sub></span> is outside or on the boundary of the circumcircle of each triangle <span class="math inline">$T \in D(\\{p_i\\})$</span>.</p>
<p>There is a nasty degenerated case when the Voronoi diagram isn't connected and Delaunay triangulation doesn't exist. This case is when all points are collinear.</p>
<h2 id="properties">Properties</h2>
<p>The Delaunay triangulation maximizes the minimum angle among all possible triangulations.</p>
<p>The Minimum Euclidean spanning tree of a point set is a subset of edges of its' Delaunay triangulation.</p>
<h2 id="duality">Duality</h2>
<p>Suppose that <span class="math inline">$\\{p_i\\}$</span> is not collinear and among <span class="math inline">$\\{p_i\\}$</span> no four points lie on one circle. Then <span class="math inline">$V(\\{p_i\\})$</span> and <span class="math inline">$D(\\{p_i\\})$</span> are dual, so if we obtain one of them, we may obtain the other in <span class="math inline"><em>O</em>(<em>n</em>)</span>. What to do if it's not the case? The collinear case may be processed easily. Otherwise, <span class="math inline"><em>V</em></span> and <span class="math inline"><em>D</em>′</span> are dual, where <span class="math inline"><em>D</em>′</span> is obtained from <span class="math inline"><em>D</em></span> by removing all the edges such that two triangles on this edge share the circumcircle.</p>
<h2 id="building-delaunay-and-voronoi">Building Delaunay and Voronoi</h2>
<p>Because of the duality, we only need a fast algorithm to compute only one of <span class="math inline"><em>V</em></span> and <span class="math inline"><em>D</em></span>. We will describe how to build <span class="math inline">$D(\\{p_i\\})$</span> in <span class="math inline"><em>O</em>(<em>n</em>log<em>n</em>)</span>. The triangulation will be built via divide-and-conquer algorithm due to Guibas and Stolfi.</p>
<h2 id="quad-edge-data-structure">Quad-edge data structure</h2>
During the algorithm <span class="math inline"><em>D</em></span> will be stored inside the quad-edge data structure. This structure is described in the picture:
<center>
<img src="&amp;imgroot&amp;/quad-edge.png" alt="Quad-Edge" />
</center>
<p>In the algorithm we will use the following functions on edges:</p>
<ol style="list-style-type: decimal">
<li><code>make_edge(a, b)</code><br> This function creates an isolated edge from point <code>a</code> to point <code>b</code> together with its' reverse edge and both dual edges.</li>
<li><code>splice(a, b)</code><br> This is a key function of the algorithm. It swaps <code>a-&gt;Onext</code> with <code>b-&gt;Onext</code> and <code>a-&gt;Onext-&gt;Rot-&gt;Onext</code> with <code>b-&gt;Onext-&gt;Rot-&gt;Onext</code>.</li>
<li><code>delete_edge(e)</code><br> This function deletes e from the triangulation. To delete <code>e</code>, we may simply call <code>splice(e, e-&gt;Oprev)</code> and <code>splice(e-&gt;Rev, e-&gt;Rev-&gt;Oprev)</code>.</li>
<li><code>connect(a, b)</code><br> This function creates a new edge <code>e</code> from <code>a-&gt;Dest</code> to <code>b-&gt;Org</code> in such a way that <code>a</code>, <code>b</code>, <code>e</code> all have the same left face. To do this, we call <code>e = make_edge(a-&gt;Dest, b-&gt;Org)</code>, <code>splice(e, a-&gt;Lnext)</code> and <code>splice(e-&gt;Rev, b)</code>.</li>
</ol>
<h2 id="algorithm">Algorithm</h2>
<p>The algorithm will compute the triangulation and return two quad-edges: the counterclockwise convex hull edge out of the leftmost vertex and the clockwise convex hull edge out of the rightmost vertex.</p>
<p>Let's sort all points by x, and if <span class="math inline"><em>x</em><sub>1</sub> = <em>x</em><sub>2</sub></span> then by y. Let's solve the problem for some segment <span class="math inline">(<em>l</em>, <em>r</em>)</span> (initially <span class="math inline">(<em>l</em>, <em>r</em>)=(0, <em>n</em> − 1)</span>). If <span class="math inline"><em>r</em> − <em>l</em> + 1 = 2</span>, we will add an edge <span class="math inline">(<em>p</em>[<em>l</em>],<em>p</em>[<em>r</em>])</span> and return. If <span class="math inline"><em>r</em> − <em>l</em> + 1 = 3</span>, we will firstly add the edges <span class="math inline">(<em>p</em>[<em>l</em>],<em>p</em>[<em>l</em> + 1])</span> and <span class="math inline">(<em>p</em>[<em>l</em> + 1],<em>p</em>[<em>r</em>])</span>. We must also connect them using <code>splice(a-&gt;Rev, b)</code>. Now we must close the triangle. Our next action will depend on the orientation of <span class="math inline"><em>p</em>[<em>l</em>],<em>p</em>[<em>l</em> + 1],<em>p</em>[<em>r</em>]</span>. If they are collinear, we can't make a triangle, so we simply return <code>(a, b-&gt;Rev)</code>. Otherwise, we create a new edge <code>c</code> by calling <code>connect(b, a)</code>. If the points are oriented counter-clockwise, we return <code>(a, b-&gt;Rev)</code>. Otherwise we return <code>(c-&gt;Rev, c)</code>.</p>
<p>Now suppose that <span class="math inline"><em>r</em> − <em>l</em> + 1 ≥ 4</span>. Firstly, let's solve <span class="math inline">$L = (l, \frac{l + r}{2})$</span> and <span class="math inline">$R = (\frac{l + r}{2} + 1, r)$</span> recursively. Now we have to merge these triangulations into one triangulation. Note that our points are sorted, so while merging we will add edges from L to R (so-called <em>cross</em> edges) and remove some edges from L to L and from R to R. What is the structure of the cross edges? All these edges must cross a line parallel to the y-axis and placed at the splitting x value. This establishes a linear ordering of the cross edges, so we can talk about successive cross edges, the bottom-most cross edge, etc. The algorithm will add the cross edges in ascending order. Note that any two adjacent cross edges will have a common endpoint, and the third side of the triangle they define goes from L to L or from R to R. Let's call the current cross edge the base. The successor of the base will either go from the left endpoint of the base to one of the R-neighbors of the right endpoint or vice versa. Consider the circumcircle of base and the previous cross edge. Suppose this circle is transformed into other circles having base as a chord but lying further into the Oy direction. Our circle will go up for a while, but unless base is an upper tangent of L and R we will encounter a point belonging either to L or to R giving rise to a new triangle without any points in the circumcircle. The new L-R edge of this triangle is the next cross edge added. To do this efficiently, we compute two edges <code>lcand</code> and <code>rcand</code> so that <code>lcand</code> points to the first L point encountered in this process, and <code>rcand</code> points to the first R point. Then we choose the one that would be encountered first. Initially base points to the lower tangent of L and R.</p>
<h2 id="implementation">Implementation</h2>
<p>Note that the implementation of the in_circle function is GCC-specific.</p>
<p>```cpp delaunay typedef long long ll;</p>
<p>bool ge(const ll&amp; a, const ll&amp; b) { return a &gt;= b; } bool le(const ll&amp; a, const ll&amp; b) { return a &lt;= b; } bool eq(const ll&amp; a, const ll&amp; b) { return a == b; } bool gt(const ll&amp; a, const ll&amp; b) { return a &gt; b; } bool lt(const ll&amp; a, const ll&amp; b) { return a &lt; b; } int sgn(const ll&amp; a) { return a &gt;= 0 ? a ? 1 : 0 : -1; }</p>
<p>struct pt { ll x, y; pt() { } pt(ll _x, ll _y) : x(_x), y(_y) { } pt operator-(const pt&amp; p) const { return pt(x - p.x, y - p.y); } ll cross(const pt&amp; p) const { return x * p.y - y * p.x; } ll cross(const pt&amp; a, const pt&amp; b) const { return (a - <em>this).cross(b - </em>this); } ll dot(const pt&amp; p) const { return x * p.x + y * p.y; } ll dot(const pt&amp; a, const pt&amp; b) const { return (a - <em>this).dot(b - </em>this); } ll sqrLength() const { return this-&gt;dot(*this); } bool operator==(const pt&amp; p) const { return eq(x, p.x) &amp;&amp; eq(y, p.y); } };</p>
<p>const pt inf_pt = pt(1e18, 1e18);</p>
<p>struct QuadEdge { pt origin; QuadEdge* rot = nullptr; QuadEdge* onext = nullptr; bool used = false; QuadEdge* rev() const { return rot-&gt;rot; } QuadEdge* lnext() const { return rot-&gt;rev()-&gt;onext-&gt;rot; } QuadEdge* oprev() const { return rot-&gt;onext-&gt;rot; } pt dest() const { return rev()-&gt;origin; } };</p>
<p>QuadEdge* make_edge(pt from, pt to) { QuadEdge* e1 = new QuadEdge; QuadEdge* e2 = new QuadEdge; QuadEdge* e3 = new QuadEdge; QuadEdge* e4 = new QuadEdge; e1-&gt;origin = from; e2-&gt;origin = to; e3-&gt;origin = e4-&gt;origin = inf_pt; e1-&gt;rot = e3; e2-&gt;rot = e4; e3-&gt;rot = e2; e4-&gt;rot = e1; e1-&gt;onext = e1; e2-&gt;onext = e2; e3-&gt;onext = e4; e4-&gt;onext = e3; return e1; }</p>
<p>void splice(QuadEdge* a, QuadEdge* b) { swap(a-&gt;onext-&gt;rot-&gt;onext, b-&gt;onext-&gt;rot-&gt;onext); swap(a-&gt;onext, b-&gt;onext); }</p>
<p>void delete_edge(QuadEdge* e) { splice(e, e-&gt;oprev()); splice(e-&gt;rev(), e-&gt;rev()-&gt;oprev()); delete e-&gt;rot; delete e-&gt;rev()-&gt;rot; delete e; delete e-&gt;rev(); }</p>
<p>QuadEdge* connect(QuadEdge* a, QuadEdge* b) { QuadEdge* e = make_edge(a-&gt;dest(), b-&gt;origin); splice(e, a-&gt;lnext()); splice(e-&gt;rev(), b); return e; }</p>
<p>bool left_of(pt p, QuadEdge* e) { return gt(p.cross(e-&gt;origin, e-&gt;dest()), 0); }</p>
<p>bool right_of(pt p, QuadEdge* e) { return lt(p.cross(e-&gt;origin, e-&gt;dest()), 0); }</p>
<p>template <class T> T det3(T a1, T a2, T a3, T b1, T b2, T b3, T c1, T c2, T c3) { return a1 * (b2 * c3 - c2 * b3) - a2 * (b1 * c3 - c1 * b3) + a3 * (b1 * c2 - c1 * b2); }</p>
<p>bool in_circle(pt a, pt b, pt c, pt d) { // If there is __int128, calculate directly. // Otherwise, calculate angles. #if defined(<strong>LP64</strong>) || defined(_WIN64) __int128 det = -det3&lt;__int128&gt;(b.x, b.y, b.sqrLength(), c.x, c.y, c.sqrLength(), d.x, d.y, d.sqrLength()); det += det3&lt;__int128&gt;(a.x, a.y, a.sqrLength(), c.x, c.y, c.sqrLength(), d.x, d.y, d.sqrLength()); det -= det3&lt;__int128&gt;(a.x, a.y, a.sqrLength(), b.x, b.y, b.sqrLength(), d.x, d.y, d.sqrLength()); det += det3&lt;__int128&gt;(a.x, a.y, a.sqrLength(), b.x, b.y, b.sqrLength(), c.x, c.y, c.sqrLength()); return det &gt; 0; #else auto ang = <a href="pt%20l,%20pt%20mid,%20pt%20r"></a> { ll x = mid.dot(l, r); ll y = mid.cross(l, r); long double res = atan2((long double)x, (long double)y); return res; }; long double kek = ang(a, b, c) + ang(c, d, a) - ang(b, c, d) - ang(d, a, b); if (kek &gt; 1e-8) return true; else return false; #endif }</p>
<p>pair<QuadEdge*, QuadEdge*> build_tr(int l, int r, vector<pt>&amp; p) { if (r - l + 1 == 2) { QuadEdge* res = make_edge(p[l], p[r]); return make_pair(res, res-&gt;rev()); } if (r - l + 1 == 3) { QuadEdge <em>a = make_edge(p[l], p[l + 1]), </em>b = make_edge(p[l + 1], p[r]); splice(a-&gt;rev(), b); int sg = sgn(p[l].cross(p[l + 1], p[r])); if (sg == 0) return make_pair(a, b-&gt;rev()); QuadEdge* c = connect(b, a); if (sg == 1) return make_pair(a, b-&gt;rev()); else return make_pair(c-&gt;rev(), c); } int mid = (l + r) / 2; QuadEdge <em>ldo, </em>ldi, <em>rdo, </em>rdi; tie(ldo, ldi) = build_tr(l, mid, p); tie(rdi, rdo) = build_tr(mid + 1, r, p); while (true) { if (left_of(rdi-&gt;origin, ldi)) { ldi = ldi-&gt;lnext(); continue; } if (right_of(ldi-&gt;origin, rdi)) { rdi = rdi-&gt;rev()-&gt;onext; continue; } break; } QuadEdge* basel = connect(rdi-&gt;rev(), ldi); auto valid = <a href="QuadEdge*%20e">&amp;basel</a> { return right_of(e-&gt;dest(), basel); }; if (ldi-&gt;origin == ldo-&gt;origin) ldo = basel-&gt;rev(); if (rdi-&gt;origin == rdo-&gt;origin) rdo = basel; while (true) { QuadEdge* lcand = basel-&gt;rev()-&gt;onext; if (valid(lcand)) { while (in_circle(basel-&gt;dest(), basel-&gt;origin, lcand-&gt;dest(), lcand-&gt;onext-&gt;dest())) { QuadEdge* t = lcand-&gt;onext; delete_edge(lcand); lcand = t; } } QuadEdge* rcand = basel-&gt;oprev(); if (valid(rcand)) { while (in_circle(basel-&gt;dest(), basel-&gt;origin, rcand-&gt;dest(), rcand-&gt;oprev()-&gt;dest())) { QuadEdge* t = rcand-&gt;oprev(); delete_edge(rcand); rcand = t; } } if (!valid(lcand) &amp;&amp; !valid(rcand)) break; if (!valid(lcand) || (valid(rcand) &amp;&amp; in_circle(lcand-&gt;dest(), lcand-&gt;origin, rcand-&gt;origin, rcand-&gt;dest()))) basel = connect(rcand, basel-&gt;rev()); else basel = connect(basel-&gt;rev(), lcand-&gt;rev()); } return make_pair(ldo, rdo); }</p>
<p>vector<tuple<pt, pt, pt>&gt; delaunay(vector<pt> p) { sort(p.begin(), p.end(), <a href="const%20pt&amp;%20a,%20const%20pt&amp;%20b"></a> { return lt(a.x, b.x) || (eq(a.x, b.x) &amp;&amp; lt(a.y, b.y)); }); auto res = build_tr(0, (int)p.size() - 1, p); QuadEdge* e = res.first; vector<QuadEdge*> edges = {e}; while (lt(e-&gt;onext-&gt;dest().cross(e-&gt;dest(), e-&gt;origin), 0)) e = e-&gt;onext; auto add = <a href="">&amp;p, &amp;e, &amp;edges</a> { QuadEdge* curr = e; do { curr-&gt;used = true; p.push_back(curr-&gt;origin); edges.push_back(curr-&gt;rev()); curr = curr-&gt;lnext(); } while (curr != e); }; add(); p.clear(); int kek = 0; while (kek &lt; (int)edges.size()) { if (!(e = edges[kek++])-&gt;used) add(); } vector<tuple<pt, pt, pt>&gt; ans; for (int i = 0; i &lt; (int)p.size(); i += 3) { ans.push_back(make_tuple(p[i], p[i + 1], p[i + 2])); } return ans; } ```</p>
</body>
</html>
