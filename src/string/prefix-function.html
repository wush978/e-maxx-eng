<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<!--?title Prefix function. Knuth–Morris–Pratt algorithm -->
<h1 id="prefix-function.-knuthmorrispratt-algorithm">Prefix function. Knuth–Morris–Pratt algorithm</h1>
<h2 id="prefix-function-definition">Prefix function definition</h2>
<p>You are given a string <span class="math inline"><em>s</em></span> of length <span class="math inline"><em>n</em></span>. The <strong>prefix function</strong> for this string is defined as an array <span class="math inline"><em>π</em></span> of length <span class="math inline"><em>n</em></span>, where <span class="math inline"><em>π</em>[<em>i</em>]</span> is the length of the longest proper prefix of the substring <span class="math inline"><em>s</em>[0…<em>i</em>]</span> which is also a suffix of this substring. A proper prefix of a string is a prefix that is not equal to the string itself. By definition, <span class="math inline"><em>π</em>[0]=0</span>.</p>
<p>Mathematically the definition of the prefix function can be written as follows:</p>
<p><br /><span class="math display">$$\pi[i] = \max_ {k = 0 \dots i} \\{k : s[0 \dots k-1] = s[i-(k-1) \dots i] \\}$$</span><br /></p>
<p>For example, prefix function of string &quot;abcabcd&quot; is <span class="math inline">[0, 0, 0, 1, 2, 3, 0]</span>, and prefix function of string &quot;aabaaab&quot; is <span class="math inline">[0, 1, 0, 1, 2, 2, 3]</span>.</p>
<h2 id="trivial-algorithm">Trivial Algorithm</h2>
<p>An algorithm which follows the definition of prefix function exactly is the following:</p>
<p><code>cpp prefix_slow vector&lt;int&gt; prefix_function(string s) {     int n = (int)s.length();     vector&lt;int&gt; pi(n);     for (int i = 0; i &lt; n; i++)         for (int k = 0; k &lt;= i; k++)             if (s.substr(0, k) == s.substr(i-k+1, k))                 pi[i] = k;     return pi; }</code></p>
<p>It is easy to see that its complexity is <span class="math inline"><em>O</em>(<em>n</em><sup>3</sup>)</span>, which has room for improvement.</p>
<h2 id="efficient-algorithm">Efficient Algorithm</h2>
<p>This algorithm was proposed by Knuth and Pratt and independently from them by Morris in 1977. It was used as the main function of a substring search algorithm.</p>
<h3 id="first-optimization">First optimization</h3>
<p>The first important observation is, that the values of the prefix function can only increase by at most one.</p>
<p>Indeed, otherwise, if <span class="math inline"><em>π</em>[<em>i</em> + 1]&gt;<em>π</em>[<em>i</em>]+1</span>, then we can take this suffix ending in position <span class="math inline"><em>i</em> + 1</span> with the length <span class="math inline"><em>π</em>[<em>i</em> + 1]</span> and remove the last character from it. We end up with a suffix ending in position <span class="math inline"><em>i</em></span> with the length <span class="math inline"><em>π</em>[<em>i</em> + 1]−1</span>, which is better than <span class="math inline"><em>π</em>[<em>i</em>]</span>, i.e. we get a contradiction.</p>
<p>The following illustration shows this contradiction. The longest proper suffix at position <span class="math inline"><em>i</em></span> that also is a prefix is of length <span class="math inline">2</span>, and at position <span class="math inline"><em>i</em> + 1</span> it is of length <span class="math inline">4</span>. Therefore the string <span class="math inline"><em>s</em><sub>0</sub> <em>s</em><sub>1</sub> <em>s</em><sub>2</sub> <em>s</em><sub>3</sub></span> is equal to the string <span class="math inline"><em>s</em><sub><em>i</em> − 2</sub> <em>s</em><sub><em>i</em> − 1</sub> <em>s</em><sub><em>i</em></sub> <em>s</em><sub><em>i</em> + 1</sub></span>, which means that also the strings <span class="math inline"><em>s</em><sub>0</sub> <em>s</em><sub>1</sub> <em>s</em><sub>2</sub></span> and <span class="math inline"><em>s</em><sub><em>i</em> − 2</sub> <em>s</em><sub><em>i</em> − 1</sub> <em>s</em><sub><em>i</em></sub></span> are equal, therefore <span class="math inline"><em>π</em>[<em>i</em>]</span> has to be <span class="math inline">3</span>. <br /><span class="math display">$$\underbrace{\overbrace{s_0 ~ s_1}^{\pi[i] = 2} ~ s_2 ~ s_3}\_{\pi[i+1] = 4} ~ \dots ~ \underbrace{s_{i-2} ~ \overbrace{s_{i-1} ~ s_{i}}^{\pi[i] = 2} ~ s_{i+1}}\_{\pi[i+1] = 4}$$</span><br /></p>
<p>Thus when moving to the next position, the value of the prefix function can either increase by one, stay the same, or decrease by some amount. This fact already allows us to reduce the complexity of the algorithm to <span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span>, because in one step the prefix function can grow at most by one. In total the function can grow at most <span class="math inline"><em>n</em></span> steps, and therefore also only can decrease a total of <span class="math inline"><em>n</em></span> steps. This means we only have to perform <span class="math inline"><em>O</em>(<em>n</em>)</span> string comparisons, and reach the complexity <span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span>.</p>
<h3 id="second-optimization">Second optimization</h3>
<p>Let's go further, we want to get rid of the string comparisons. To accomplish this, we have to use all the information computed in the previous steps.</p>
<p>So let us compute the value of the prefix function <span class="math inline"><em>π</em></span> for <span class="math inline"><em>i</em> + 1</span>. If <span class="math inline"><em>s</em>[<em>i</em> + 1]=<em>s</em>[<em>π</em>[<em>i</em>]]</span>, then we can say with certainty that <span class="math inline"><em>π</em>[<em>i</em> + 1]=<em>π</em>[<em>i</em>]+1</span>, since we already know that the suffix at position <span class="math inline"><em>i</em></span> of length <span class="math inline"><em>π</em>[<em>i</em>]</span> is equal to the prefix of length <span class="math inline"><em>π</em>[<em>i</em>]</span>. This is illustrated again with an example. <br /><span class="math display">$$\underbrace{\overbrace{s_0 ~ s_1 ~ s_2}^{\pi[i]} ~ \overbrace{s_3}^{s_3 = s_{i+1}}}\_{\pi[i+1] = \pi[i] + 1} ~ \dots ~ \underbrace{\overbrace{s_{i-2} ~ s_{i-1} ~ s_{i}}^{\pi[i]} ~ \overbrace{s_{i+1}}^{s_3 = s_i + 1}}\_{\pi[i+1] = \pi[i] + 1}$$</span><br /></p>
<p>If this is not the case, <span class="math inline"><em>s</em>[<em>i</em> + 1]≠<em>s</em>[<em>π</em>[<em>i</em>]]</span>, then we need to try a shorter string. In order to speed things up, we would like to immediately move to the longest length <span class="math inline"><em>j</em> &lt; <em>π</em>[<em>i</em>]</span>, such that the prefix property in the position <span class="math inline"><em>i</em></span> holds, i.e. <span class="math inline"><em>s</em>[0…<em>j</em> − 1]=<em>s</em>[<em>i</em> − <em>j</em> + 1…<em>i</em>]</span>: <br /><span class="math display">$$\overbrace{\underbrace{s_0 ~ s_1}\_j ~ s_2 ~ s_3}^{\pi[i]} ~ \dots ~ \overbrace{s_{i-3} ~ s_{i-2} ~ \underbrace{s_{i-1} ~ s_{i}}\_j}^{\pi[i]} ~ s_{i+1}$$</span><br /></p>
<p>Indeed, if we find such a length <span class="math inline"><em>j</em></span>, then we again only need to compare the characters <span class="math inline"><em>s</em>[<em>i</em> + 1]</span> and <span class="math inline"><em>s</em>[<em>j</em>]</span>. If they are equal, then we can assign <span class="math inline"><em>π</em>[<em>i</em> + 1]=<em>j</em> + 1</span>. Otherwise we will need to find the largest value smaller than <span class="math inline"><em>j</em></span>, for which the prefix property holds, and so on. It can happen that this goes until <span class="math inline"><em>j</em> = 0</span>. If then <span class="math inline"><em>s</em>[<em>i</em> + 1]=<em>s</em>[0]</span>, we assign <span class="math inline"><em>π</em>[<em>i</em> + 1]=1</span>, and <span class="math inline"><em>π</em>[<em>i</em> + 1]=0</span> otherwise.</p>
<p>So we already have a general scheme of the algorithm. The only question left is how do we effectively find the lengths for <span class="math inline"><em>j</em></span>. Let's recap: for the current length <span class="math inline"><em>j</em></span> at the position <span class="math inline"><em>i</em></span> for which the prefix property holds, i.e. <span class="math inline"><em>s</em>[0…<em>j</em> − 1]=<em>s</em>[<em>i</em> − <em>j</em> + 1…<em>i</em>]</span>, we want to find the greatest <span class="math inline"><em>k</em> &lt; <em>j</em></span>, for which the prefix property holds. <br /><span class="math display">$$\overbrace{\underbrace{s_0 ~ s_1}\_k ~ s_2 ~ s_3}^j ~ \dots ~ \overbrace{s_{i-3} ~ s_{i-2} ~ \underbrace{s_{i-1} ~ s_{i}}\_k}^j ~s_{i+1}$$</span><br /></p>
<p>The illustration shows, that this has to be the value of <span class="math inline"><em>π</em>[<em>j</em> − 1]</span>, which we already calculated earlier.</p>
<h3 id="final-algorithm">Final algorithm</h3>
<p>So we finally can build an algorithm that doesn't perform any string comparisons and only performs <span class="math inline"><em>O</em>(<em>n</em>)</span> actions.</p>
<p>Here is the final procedure:</p>
<ul>
<li>We compute the prefix values <span class="math inline"><em>π</em>[<em>i</em>]</span> in a loop by iterating from <span class="math inline"><em>i</em> = 1</span> to <span class="math inline"><em>i</em> = <em>n</em> − 1</span> (<span class="math inline"><em>π</em>[0]</span> just gets assigned with <span class="math inline">0</span>).</li>
<li>To calculate the current value <span class="math inline"><em>π</em>[<em>i</em>]</span> we set the variable <span class="math inline"><em>j</em></span> denoting the length of the best suffix for <span class="math inline"><em>i</em> − 1</span>. Initially <span class="math inline"><em>j</em> = <em>π</em>[<em>i</em> − 1]</span>.</li>
<li>Test if the suffix of length <span class="math inline"><em>j</em> + 1</span> is also a prefix by comparing <span class="math inline"><em>s</em>[<em>j</em>]</span> and <span class="math inline"><em>s</em>[<em>i</em>]</span>. If they are equal then we assign <span class="math inline"><em>π</em>[<em>i</em>]=<em>j</em> + 1</span>, otherwise we reduce <span class="math inline"><em>j</em></span> to <span class="math inline"><em>π</em>[<em>j</em> − 1]</span> and repeat this step.</li>
<li>If we have reached the length <span class="math inline"><em>j</em> = 0</span> and still don't have a match, then we assign <span class="math inline"><em>π</em>[<em>i</em>]=0</span> and go to the next index <span class="math inline"><em>i</em> + 1</span>.</li>
</ul>
<h3 id="implementation">Implementation</h3>
<p>The implementation ends up being surprisingly short and expressive.</p>
<p><code>cpp prefix_fast vector&lt;int&gt; prefix_function(string s) {     int n = (int)s.length();     vector&lt;int&gt; pi(n);     for (int i = 1; i &lt; n; i++) {         int j = pi[i-1];         while (j &gt; 0 &amp;&amp; s[i] != s[j])             j = pi[j-1];         if (s[i] == s[j])             j++;         pi[i] = j;     }     return pi; }</code></p>
<p>This is an <strong>online</strong> algorithm, i.e. it processes the data as it arrives - for example, you can read the string characters one by one and process them immediately, finding the value of prefix function for each next character. The algorithm still requires storing the string itself and the previously calculated values of prefix function, but if we know beforehand the maximum value <span class="math inline"><em>M</em></span> the prefix function can take on the string, we can store only <span class="math inline"><em>M</em> + 1</span> first characters of the string and the same number of values of the prefix function.</p>
<h2 id="applications">Applications</h2>
<h3 id="search-for-a-substring-in-a-string.-the-knuth-morris-pratt-algorithm">Search for a substring in a string. The Knuth-Morris-Pratt algorithm</h3>
<p>The task is the classical application of the prefix function.</p>
<p>Given a text <span class="math inline"><em>t</em></span> and a string <span class="math inline"><em>s</em></span>, we want to find and display the positions of all occurrences of the string <span class="math inline"><em>s</em></span> in the text <span class="math inline"><em>t</em></span>.</p>
<p>For convenience we denote with <span class="math inline"><em>n</em></span> the length of the string s and with <span class="math inline"><em>m</em></span> the length of the text <span class="math inline"><em>t</em></span>.</p>
<p>We generate the string <span class="math inline">$s + \\# + t$</span>, where <span class="math inline">$\\#$</span> is a separator that appear in <span class="math inline"><em>s</em></span> and neither in <span class="math inline"><em>t</em></span>. Let us calculate the prefix function for this string. Now think about the meaning of the values of the prefix function, except for the first <span class="math inline"><em>n</em> + 1</span> entries (which belong to the string <span class="math inline"><em>s</em></span> and the separator). By definition the value <span class="math inline"><em>π</em>[<em>i</em>]</span> shows the longest length of a substring ending in position <span class="math inline"><em>i</em></span> that coincides with the prefix. But in our case this is nothing more than the largest block that coincides with <span class="math inline"><em>s</em></span> and ends at position <span class="math inline"><em>i</em></span>. This length cannot be bigger than <span class="math inline"><em>n</em></span> due to the separator. But if equality <span class="math inline"><em>π</em>[<em>i</em>]=<em>n</em></span> is achieved, then it means that the string <span class="math inline"><em>s</em></span> appears completely in at this position, i.e. it ends at position <span class="math inline"><em>i</em></span>. Just do not forget that the positions are indexed in the string <span class="math inline">$s + \\# + t$</span>.</p>
<p>Thus if at some position <span class="math inline"><em>i</em></span> we have <span class="math inline"><em>π</em>[<em>i</em>]=<em>n</em></span>, then at the position <span class="math inline"><em>i</em> − (<em>n</em> − 1)−<em>n</em> + 1 = <em>i</em> − 2<em>n</em></span> in the string <span class="math inline"><em>t</em></span> the string <span class="math inline"><em>s</em></span> appears.</p>
<p>As already mentioned in the description of the prefix function computation, if we know that the prefix values never exceed a certain value, then we do not need to store the entire string and the entire function, but only its beginning. In our case this means that we only need to store the string <span class="math inline">$s + \\#$</span> and the values of the prefix function for it. We can read one character at a time of the string <span class="math inline"><em>t</em></span> and calculate the current value of the prefix function.</p>
<p>Thus the Knuth-Morris-Pratt algorithm solves the problem in <span class="math inline"><em>O</em>(<em>n</em> + <em>m</em>)</span> time and <span class="math inline"><em>O</em>(<em>n</em>)</span> memory.</p>
<h3 id="counting-the-number-of-occurrences-of-each-prefix">Counting the number of occurrences of each prefix</h3>
<p>Here we discuss two problems at once. Given a string <span class="math inline"><em>s</em></span> of length <span class="math inline"><em>n</em></span>. In the first variation of the problem we want to count the number of appearances of each prefix <span class="math inline"><em>s</em>[0…<em>i</em>]</span> in the same string. In the second variation of the problem another string <span class="math inline"><em>t</em></span> is given and we want to count the number of appearances of each prefix <span class="math inline"><em>s</em>[0…<em>i</em>]</span> in <span class="math inline"><em>t</em></span>.</p>
<p>First we solve the first problem. Consider the value of the prefix function <span class="math inline"><em>π</em>[<em>i</em>]</span> at a position <span class="math inline"><em>i</em></span>. By definition it means that in position <span class="math inline"><em>i</em></span> the prefix of length <span class="math inline"><em>π</em>[<em>i</em>]</span> of the string <span class="math inline"><em>s</em></span> appears and ends at position <span class="math inline"><em>i</em></span>, and there doesn't exists a longer prefix that follows this definition. At the same time shorter prefixes can end at this position. It is not difficult to see, that we have the same question that we already answered when we computed the prefix function itself: Given a prefix of length <span class="math inline"><em>j</em></span> that is a suffix ending at position <span class="math inline"><em>i</em></span>, what is the next smaller prefix <span class="math inline">&lt;<em>j</em></span> that is also a suffix ending at position <span class="math inline"><em>i</em></span>. Thus at the position <span class="math inline"><em>i</em></span> ends the prefix of length <span class="math inline"><em>π</em>[<em>i</em>]</span>, the prefix of length <span class="math inline"><em>π</em>[<em>π</em>[<em>i</em>]−1]</span>, the prefix <span class="math inline"><em>π</em>[<em>π</em>[<em>π</em>[<em>i</em>]−1]−1]</span>, and so on, until the index becomes zero. Thus we can compute the answer in the following way.</p>
<p><code>cpp prefix_count_each_prefix vector&lt;int&gt; ans(n + 1); for (int i = 0; i &lt; n; i++)     ans[pi[i]]++; for (int i = n-1; i &gt; 0; i--)     ans[pi[i-1]] += ans[i]; for (int i = 0; i &lt;= n; i++)     ans[i]++;</code></p>
<p>Here for each value of the prefix function we first count how many times it occurs in the array <span class="math inline"><em>π</em></span>, and then compute the final answers: if we know that the length prefix <span class="math inline"><em>i</em></span> appears exactly <span class="math inline">ans[<em>i</em>]</span> times, then this number must be added to the number of occurrences of its longest suffix that is also a prefix. At the end we need to add <span class="math inline">1</span> to each result, since we also need to count the original prefixes also.</p>
<p>Now let us consider the second problem. We apply the trick from Knuth-Morris-Pratt: we create the string <span class="math inline">$s + \\# + t$</span> and compute its prefix function. The only differences to the first task is, that we are only interested in the prefix values that relate to the string <span class="math inline"><em>t</em></span>, i.e. <span class="math inline"><em>π</em>[<em>i</em>]</span> for <span class="math inline"><em>i</em> ≥ <em>n</em> + 1</span>. With those values we can perform the exact same computations as in the first task.</p>
<h3 id="the-number-of-different-substring-in-a-string">The number of different substring in a string</h3>
<p>Given a string <span class="math inline"><em>s</em></span> of length <span class="math inline"><em>n</em></span>. We want to compute the number of different substrings appearing in it.</p>
<p>We will solve this problem iteratively. Namely we will learn, knowing the current number of different substrings, how to recompute this count by adding a character to the end.</p>
<p>So let <span class="math inline"><em>k</em></span> be the current number of different substrings in <span class="math inline"><em>s</em></span>, and we add the character <span class="math inline"><em>c</em></span> to the end of <span class="math inline"><em>s</em></span>. Obviously some new substrings ending in <span class="math inline"><em>c</em></span> will appear. We want to count these new substrings that didn't appear before.</p>
<p>We take the string <span class="math inline"><em>t</em> = <em>s</em> + <em>c</em></span> and reverse it. Now the task is transformed into computing how many prefixes there are that don't appear anywhere else. If we compute the maximal value of the prefix function <span class="math inline"><em>π</em><sub>max</sub></span> of the reversed string <span class="math inline"><em>t</em></span>, then the longest prefix that appears in <span class="math inline"><em>s</em></span> is <span class="math inline"><em>π</em><sub>max</sub></span> long. Clearly also all prefixes of smaller length appear in it.</p>
<p>Therefore the number of new substrings appearing when we add a new character <span class="math inline"><em>c</em></span> is <span class="math inline">|<em>s</em>|+1 − <em>π</em><sub>max</sub></span>.</p>
<p>So for each character appended we can compute the number of new substrings in <span class="math inline"><em>O</em>(<em>n</em>)</span> times, which gives a time complexity of <span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span> in total.</p>
<p>It is worth noting, that we can also compute the number of different substrings by appending the characters at the beginning, or by deleting characters from the beginning or the end.</p>
<h3 id="compressing-a-string">Compressing a string</h3>
<p>Given a string <span class="math inline"><em>s</em></span> of length <span class="math inline"><em>n</em></span>. We want to find the shortest &quot;compressed&quot; representation of the string, i.e. we want to find a string <span class="math inline"><em>t</em></span> of smallest length such that <span class="math inline"><em>s</em></span> can be represented as a concatenation of one or more copies of <span class="math inline"><em>t</em></span>.</p>
<p>It is clear, that we only need to find the length of <span class="math inline"><em>t</em></span>. Knowing the length, the answer to the problem will be the prefix of <span class="math inline"><em>s</em></span> with this length.</p>
<p>Let us compute the prefix function for <span class="math inline"><em>s</em></span>. Using the last value of it we define the value <span class="math inline"><em>k</em> = <em>n</em> − <em>π</em>[<em>n</em> − 1]</span>. We will show, that if <span class="math inline"><em>k</em></span> divides <span class="math inline"><em>n</em></span>, then <span class="math inline"><em>k</em></span> will be the answer, otherwise there doesn't exists an effective compression and the answer is <span class="math inline"><em>n</em></span>.</p>
<p>Let <span class="math inline"><em>n</em></span> be divisible by <span class="math inline"><em>k</em></span>. Then the string can be partitioned into blocks of the length <span class="math inline"><em>k</em></span>. By definition of the prefix function, the prefix of length <span class="math inline"><em>n</em> − <em>k</em></span> will be equal with its suffix. But this means that the last block is equal to the block before. And the block before has to be equal to the block before it. And so on. As a result, it turns out that all blocks are equal, therefore we can compress the string <span class="math inline"><em>s</em></span> to length <span class="math inline"><em>k</em></span>.</p>
<p>Of course we still need to show that this is actually the optimum. Indeed, if there was a smaller compression than <span class="math inline"><em>k</em></span>, than the prefix function at the end would be greater than <span class="math inline"><em>n</em> − <em>k</em></span>. Therefore <span class="math inline"><em>k</em></span> has is really the answer.</p>
<p>Now let us assume that <span class="math inline"><em>n</em></span> is not divisible by <span class="math inline"><em>k</em></span>. We show that this implies that the length of the answer is <span class="math inline"><em>n</em></span>. We prove it by contradiction. Assuming there exists an answer, and the compression has length <span class="math inline"><em>p</em></span> (<span class="math inline"><em>p</em></span> divides <span class="math inline"><em>n</em></span>). Then the last value of the prefix function has to be greater than <span class="math inline"><em>n</em> − <em>p</em></span>, i.e. the suffix will partially cover the first block. Now consider the second block of the string. Since the prefix is equal with the suffix, and both the prefix and the suffix cover this block and their displacement relative to each other <span class="math inline"><em>k</em></span> does not divide the block length <span class="math inline"><em>p</em></span> (otherwise <span class="math inline"><em>k</em></span> divides <span class="math inline"><em>n</em></span>), then all the characters of the block have to be identical. But then the string consists of only one character repeated over and over, hence we can compress it to a string of size <span class="math inline">1</span>, which gives <span class="math inline"><em>k</em> = 1</span>, and <span class="math inline"><em>k</em></span> divides <span class="math inline"><em>n</em></span>. Contradiction.</p>
<p><br /><span class="math display">$$\overbrace{s_0 ~ s_1 ~ s_2 ~ s_3}^p ~ \overbrace{s_4 ~ s_5 ~ s_6 ~ s_7}^p$$</span><br /> <br /><span class="math display">$$s_0 ~ s_1 ~ s_2 ~ \underbrace{\overbrace{s_3 ~ s_4 ~ s_5 ~ s_6}^p ~ s_7}_{\pi[7] = 5}$$</span><br /> <br /><span class="math display"><em>s</em><sub>4</sub> = <em>s</em><sub>3</sub>,  <em>s</em><sub>5</sub> = <em>s</em><sub>4</sub>,  <em>s</em><sub>6</sub> = <em>s</em><sub>5</sub>,  <em>s</em><sub>7</sub> = <em>s</em><sub>6</sub>  ⇒  <em>s</em><sub>0</sub> = <em>s</em><sub>1</sub> = <em>s</em><sub>2</sub> = <em>s</em><sub>3</sub></span><br /></p>
<h3 id="building-an-automaton-according-to-the-prefix-function">Building an automaton according to the prefix function</h3>
<p>Let's return to the concatenation to the two strings through a separator, i.e. for the strings <span class="math inline"><em>s</em></span> and <span class="math inline"><em>t</em></span> we compute the prefix function for the string <span class="math inline">$s + \\# + t$</span>. Obviously, since <span class="math inline">$\\#$</span> is a separator, the value of the prefix function will never exceed <span class="math inline">|<em>s</em>|</span>. If follows, that it is sufficient to only store the string <span class="math inline">$s + \\#$</span> and the values of the prefix function for it, and we can compute the prefix function for all subsequent character on the fly: <br /><span class="math display">$$\underbrace{s_0 ~ s_1 ~ \dots ~ s_{n-1} ~ \\#}\_{\text{need to store}} ~ \underbrace{t_0 ~ t_1 ~ \dots ~ t_{m-1}}\_{\text{do not need to store}}$$</span><br /></p>
<p>Indeed, in such a situation, knowing the next character <span class="math inline"><em>c</em> ∈ <em>t</em></span> and the value of the prefix function of the previous position is enough information to compute the next value of the prefix function, without using any previous characters of the string <span class="math inline"><em>t</em></span> and the value of the prefix function in them.</p>
<p>In other words, we can construct an <strong>automaton</strong> (a finite state machine): the state in it is the current value of the prefix function, and the transition from one state to another will be performed via the next character.</p>
<p>Thus, even without having the string <span class="math inline"><em>t</em></span>, we can construct such a transition table <span class="math inline">$(\text{old}\\_\pi, c) \rightarrow \text{new}\\_\pi$</span> using the same algorithm as for calculating the transition table:</p>
<p><code>cpp prefix_automaton_slow void compute_automaton(string s, vector&lt;vector&lt;int&gt;&gt;&amp; aut) {     s += '#';     int n = s.size();     vector&lt;int&gt; pi = prefix_function(s);     aut.assign(n, vector&lt;int&gt;(26));     for (int i = 0; i &lt; n; i++) {         for (int c = 0; c &lt; 26; c++) {             int j = i;             while (j &gt; 0 &amp;&amp; 'a' + c != s[j])                 j = pi[j-1];             if ('a' + c == s[j])                 j++;             aut[i][c] = j;         }     } }</code></p>
<p>However in this form the algorithm runs in <span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>26)</span> time for the lowercase letters of the alphabet. Note that we can apply dynamic programming and use the already calculated parts of the table. Whenever we go from the value <span class="math inline"><em>j</em></span> to the value <span class="math inline"><em>π</em>[<em>j</em> − 1]</span>, we actually mean that the transition <span class="math inline">(<em>j</em>, <em>c</em>)</span> leads to the same state as the transition as <span class="math inline">(<em>π</em>[<em>j</em> − 1],<em>c</em>)</span>, and this answer is already accurately computed.</p>
<p><code>cpp prefix_automaton_fast void compute_automaton(string s, vector&lt;vector&lt;int&gt;&gt;&amp; aut) {     s += '#';     int n = s.size();     vector&lt;int&gt; pi = prefix_function(s);     aut.assign(n, vector&lt;int&gt;(26));     for (int i = 0; i &lt; n; i++) {         for (int c = 0; c &lt; 26; c++) {             if (i &gt; 0 &amp;&amp; 'a' + c != s[i])                 aut[i][c] = aut[pi[i-1]][c];             else                 aut[i][c] = i + ('a' + c == s[i]);         }     } }</code></p>
<p>As a result we construct the automaton in <span class="math inline"><em>O</em>(<em>n</em>26)</span> time.</p>
<p>When is such a automaton useful? To begin with, remember that we use the prefix function for the string <span class="math inline">$s + \\# + t$</span> and its values mostly for a single purpose: find all occurrences of the string <span class="math inline"><em>s</em></span> in the string <span class="math inline"><em>t</em></span>.</p>
<p>Therefore the most obvious benefit of this automaton is the <strong>acceleration of calculating the prefix function</strong> for the string <span class="math inline">$s + \\# + t$</span>. By building the automaton for <span class="math inline">$s + \\#$</span>, we no longer need to store the string <span class="math inline"><em>s</em></span> or the values of the prefix function in it. All transitions are already computed in the table.</p>
<p>But there is a second, less obvious, application. We can use the automaton when the string <span class="math inline"><em>t</em></span> is a <strong>gigantic string constructed using some rules</strong>. This can for instance be the Gray strings, or a string formed by a recursive combination of several short strings from the input.</p>
<p>For completeness we will solve such a problem: given a number <span class="math inline"><em>k</em> ≤ 10<sup>5</sup></span> and a string <span class="math inline"><em>s</em></span> of length <span class="math inline">≤10<sup>5</sup></span>. We have to compute the number of occurrences of <span class="math inline"><em>s</em></span> in the <span class="math inline"><em>k</em></span>-th Gray string. Recall that Gray's strings are define in the following way: <br /><span class="math display">$$\begin{align}
g_1 &amp;= &quot;a&quot;\\\\
g_2 &amp;= &quot;aba&quot;\\\\
g_3 &amp;= &quot;abacaba&quot;\\\\
g_4 &amp;= &quot;abacabadabacaba&quot;
\end{align}$$</span><br /></p>
<p>In such cases even constructing the string <span class="math inline"><em>t</em></span> will be impossible, because of its astronomical length. The <span class="math inline"><em>k</em></span>-th Gray string is <span class="math inline">2<sup><em>k</em></sup> − 1</span> characters long. However we can calculate the value of the prefix function at the end of the string effectively, by only knowing the value of the prefix function at the start.</p>
<p>In addition to the automaton itself, we also compute values <span class="math inline"><em>G</em>[<em>i</em>][<em>j</em>]</span> - the value of the automaton after processing the string <span class="math inline"><em>g</em><sub><em>i</em></sub></span> starting with the state <span class="math inline"><em>j</em></span>. And additionally we compute values <span class="math inline"><em>K</em>[<em>i</em>][<em>j</em>]</span> - the number of occurrences of <span class="math inline"><em>s</em></span> in <span class="math inline"><em>g</em><sub><em>i</em></sub></span>, before during the processing of <span class="math inline"><em>g</em><sub><em>i</em></sub></span> starting with the state <span class="math inline"><em>j</em></span>. Actually <span class="math inline"><em>K</em>[<em>i</em>][<em>j</em>]</span> is the number of times that the prefix function took the value <span class="math inline">|<em>s</em>|</span> while performing the operations. The answer to the problem will then be <span class="math inline"><em>K</em>[<em>k</em>][0]</span>.</p>
<p>How can we compute these values? First the basic values are <span class="math inline"><em>G</em>[0][<em>j</em>]=<em>j</em></span> and <span class="math inline"><em>K</em>[0][<em>j</em>]=0</span>. And all subsequent values can be calculated from the previous values and using the automaton. To calculate the value for some <span class="math inline"><em>i</em></span> we remember that the string <span class="math inline"><em>g</em><sub><em>i</em></sub></span> consists of <span class="math inline"><em>g</em><sub><em>i</em> − 1</sub></span>, the <span class="math inline"><em>i</em></span> character of the alphabet, and <span class="math inline"><em>g</em><sub><em>i</em> − 1</sub></span>. Thus the automaton will go into the state: <br /><span class="math display">mid = aut[<em>G</em>[<em>i</em> − 1][<em>j</em>]][<em>i</em>]</span><br /> <br /><span class="math display"><em>G</em>[<em>i</em>][<em>j</em>]=<em>G</em>[<em>i</em> − 1][mid]</span><br /> The values for <span class="math inline"><em>K</em>[<em>i</em>][<em>j</em>]</span> can also be easily counted. <br /><span class="math display"><em>K</em>[<em>i</em>][<em>j</em>]=<em>K</em>[<em>i</em> − 1][<em>j</em>]+(mid = =|<em>s</em>|) + <em>K</em>[<em>i</em> − 1][mid]</span><br /></p>
<p>So we can solve the problem for Gray strings, and similarly also a huge number of other similar problems. For example the exact same method also solves the following problem: we are given a string <span class="math inline"><em>s</em></span> and some patterns <span class="math inline"><em>t</em><sub><em>i</em></sub></span>, each of which is specified as follows: it is a string of ordinary characters, and there might be some recursive insertions of the previous strings of the form <span class="math inline"><em>t</em><sub><em>k</em></sub><sup>cnt</sup></span>, which means that at this place we have to insert the string <span class="math inline"><em>t</em><sub><em>k</em></sub></span> <span class="math inline">cnt</span> times. An example of such patterns: <br /><span class="math display">$$\begin{align}
t_1 &amp;= &quot;abdeca&quot;\\\\
t_2 &amp;= &quot;abc&quot; + t_1^{30} + &quot;abd&quot;\\\\
t_3 &amp;= t_2^{50} + t_1^{100}\\\\
t_4 &amp;= t_2^{10} + t_3^{100}
\end{align}$$</span><br /></p>
<p>The recursive substitutions blow the string up, so that their lengths can reach the order of <span class="math inline">100<sup>100</sup></span>.</p>
<p>We have to find the number of times the string <span class="math inline"><em>s</em></span> appears in each of the strings.</p>
<p>The problem can be solved in the same way by constructing the automaton of the prefix function, and then we calculate the transitions in for each pattern by using the previous results.</p>
<h2 id="practice-problems">Practice Problems</h2>
<ul>
<li><a href="http://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=396">UVA # 455 &quot;Periodic Strings&quot;</a></li>
<li><a href="http://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=1963">UVA # 11022 &quot;String Factoring&quot;</a></li>
<li><a href="http://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=2447">UVA # 11452 &quot;Dancing the Cheeky-Cheeky&quot;</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4282">UVA 12604 - Caesar Cipher</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3911">UVA 12467 - Secret Word</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=1960">UVA 11019 - Matrix Matcher</a></li>
<li><a href="http://www.spoj.com/problems/NAJPF/">SPOJ - Pattern Find</a></li>
<li><a href="http://codeforces.com/contest/808/problem/G">Codeforces - Anthem of Berland</a></li>
</ul>
</body>
</html>
