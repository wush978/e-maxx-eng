<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<!--?title Aho-Corasick algorithm -->
<h1 id="aho-corasick-algorithm">Aho-Corasick algorithm</h1>
<p>Let there be a set of strings with the total length <span class="math inline"><em>m</em></span> (sum of all lengths). The Aho-Corasick algorithm constructs a data structure similar to a trie with some additional links, and then constructs a finite state machine (automaton) in <span class="math inline"><em>O</em>(<em>m</em><em>k</em>)</span> time, where <span class="math inline"><em>k</em></span> is the size of the used alphabet.</p>
<p>The algorithm was proposed by Alfred Aho and Margaret Corasick in 1975.</p>
<h2 id="construction-of-the-trie">Construction of the trie</h2>
<p>Formally a trie is a rooted tree, where each edge of the tree is labeled by some letter. All outgoing edge from one vertex mush have different labels.</p>
<p>Consider any path in the trie from the root to any vertex. If we write out the labels of all edges on the path, we get a string that corresponds to this path. For any vertex in the trie we will associate the string from the root to the vertex.</p>
<p>Each vertex will also have a flag <span class="math inline">leaf</span> which will be true, if any string from the given set corresponds to this vertex.</p>
<p>Accordingly to build a trie for a set of strings means to build a trie such that each <span class="math inline">leaf</span> vertex will correspond to one string from the set, and conversely that each string of the set corresponds to one <span class="math inline">leaf</span> vertex.</p>
<p>We now describe how to construct a trie for a given set of strings in linear time with respect to their total length.</p>
<p>We introduce a structure for the vertices of the tree.</p>
<p>```cpp aho_corasick_trie_definition const int K = 26;</p>
<p>struct Vertex { int next[K]; bool leaf = false;</p>
<pre><code>Vertex() {
    fill(begin(next), end(next), -1);
}</code></pre>
<p>};</p>
<p>vector<Vertex> trie(1); ```</p>
<p>Here we store the trie as an array of <span class="math inline">Vertex</span>. Each <span class="math inline">Vertex</span> contains the flag <span class="math inline">leaf</span>, and the edges in the form of ans array <span class="math inline">next[]</span>, where <span class="math inline">next[<em>i</em>]</span> is the index to the vertex that we reach by following the character <span class="math inline"><em>i</em></span>, or <span class="math inline">−1</span>, if there is no such edge. Initially the trie consists of only one vertex - the root - with the index <span class="math inline">0</span>.</p>
<p>Now we implement a function that will add a string <span class="math inline"><em>s</em></span> to the trie. The implementation is extremely simple: we start at the root node, and as long as there are edges corresponding to the characters of <span class="math inline"><em>s</em></span> we follow them. If there is no edge for one character, we simply generate a new vertex and connect it via an edge. At the end of the process we mark the last vertex with flag <span class="math inline">leaf</span>.</p>
<p><code>cpp aho_corasick_trie_add void add_string(string const&amp; s) {     int v = 0;     for (char ch : s) {         int c = ch - 'a';         if (trie[v].next[c] == -1) {             trie[v].next[c] = trie.size();             trie.emplace_back();         }         v = trie[v].next[c];     }     trie[v].leaf = true; }</code></p>
<p>The implementation obviously runs in linear time. And since every vertex store <span class="math inline"><em>k</em></span> links, it will use <span class="math inline"><em>O</em>(<em>m</em><em>k</em>)</span> memory.</p>
<p>It is possible to decrease the memory consumption to <span class="math inline"><em>O</em>(<em>m</em>)</span> by using a map instead of an array in each vertex. However this will increase the complexity to <span class="math inline"><em>O</em>(<em>n</em>log<em>k</em>)</span>.</p>
<h2 id="construction-of-an-automaton">Construction of an automaton</h2>
<p>Suppose we have built a trie for the given set of strings. Now let's look at it from a different side. If we look at any vertex. The string that corresponds to it is a prefix of one or more strings in the set, thus each vertex of the trie can be interpreted as a position in one or more strings from the set.</p>
<p>In fact the trie vertices can be interpreted as states in a <strong>finite deterministic automaton</strong>. From any state we can transition - using some input letter - to other states, i.e. to another position in the set of strings. For example, if there is only one string in the trie <span class="math inline"><em>a</em><em>b</em><em>c</em></span>, and we are standing at vertex <span class="math inline">2</span> (which corresponds to the string <span class="math inline"><em>a</em><em>b</em></span>), then using the letter <span class="math inline"><em>c</em></span> we can transition to the state <span class="math inline">3</span>.</p>
<p>Thus we can understand the edges of the trie as transitions in an automaton according to the corresponding letter. However for an automaton we cannot restrict the possible transitions for each state. If we try to perform a transition using a letter, and there is no corresponding edge in the trie, then we nevertheless must go into some state.</p>
<p>More strictly, let us be in a state <span class="math inline"><em>p</em></span> corresponding to the string <span class="math inline"><em>t</em></span>, and we want to transition to a different state with the character <span class="math inline"><em>c</em></span>. If the is an edge labeled with this letter <span class="math inline"><em>c</em></span>, then we can simply go over this edge, and get the vertex corresponding to <span class="math inline"><em>t</em> + <em>c</em></span>. If there is no such edge, then we must find the state corresponding to the longest proper suffix of the string <span class="math inline"><em>t</em></span> (the longest available in the trie), and try to perform a transition via <span class="math inline"><em>c</em></span> from there.</p>
<p>For example let the trie be constructed by the strings <span class="math inline"><em>a</em><em>b</em></span> and <span class="math inline"><em>b</em><em>c</em></span>, and we are currently at the vertex corresponding to <span class="math inline"><em>a</em><em>b</em></span>, which is a <span class="math inline">leaf</span>. For a transition with the letter <span class="math inline"><em>c</em></span>, we are forced to go to the state corresponding to the string <span class="math inline"><em>b</em></span>, and from there follow the edge with the letter <span class="math inline"><em>c</em></span>.</p>
<p>A <strong>suffix link</strong> for a vertex <span class="math inline"><em>p</em></span> is a edge that points to the longest proper suffix of the string corresponding to the vertex <span class="math inline"><em>p</em></span>. The only special case is the root of the trie, the suffix link will point to itself. Now we can reformulate the statement about the transitions in the automaton like this: while from the current vertex of the trie there is no transition using the current letter (or until we reach the root), we follow the suffix link.</p>
<p>Thus we reduced the problem of constructing an automaton to the problem of finding suffix links for all vertices of the trie. However we will build these suffix links, oddly enough, using the transitions constructed in the automaton.</p>
<p>Note that if we want to find a suffix link for some vertex <span class="math inline"><em>v</em></span>, then we can go to the ancestor <span class="math inline"><em>p</em></span> of the current vertex (let <span class="math inline"><em>c</em></span> be the letter of the edge from <span class="math inline"><em>p</em></span> to <span class="math inline"><em>v</em></span>), then follow its suffix link, and perform from there the transition with the letter <span class="math inline"><em>c</em></span>.</p>
<p>Thus the problem of finding the transitions has been reduced to the problem of finding suffix links, and the problem of finding suffix links has been reduced to the problem of finding a suffix link and a transition, but for vertices closer to the root. So we have a recursive dependence that we can resolve in linear time.</p>
<p>Let's move to the implementation. Note that we now will store the ancestor <span class="math inline"><em>p</em></span> and the character <span class="math inline"><em>p</em><em>c</em><em>h</em></span> of the edge from <span class="math inline"><em>p</em></span> to <span class="math inline"><em>v</em></span> for each vertex <span class="math inline"><em>v</em></span>. Also at each vertex we will store the suffix link <span class="math inline">link</span> (or <span class="math inline">−1</span> if it hasn't been calculated yet), and in the array <span class="math inline">go[<em>k</em>]</span> the transitions in the machine for each symbol (again <span class="math inline">−1</span> if it hasn't been calculated yet).</p>
<p>```cpp aho_corasick_automaton const int K = 26;</p>
<p>struct Vertex { int next[K]; bool leaf = false; int p = -1; char pch; int link = -1; int go[K];</p>
<pre><code>Vertex(int p=-1, char ch=&#39;$&#39;) : p(p), pch(ch) {
    fill(begin(next), end(next), -1);
    fill(begin(go), end(go), -1);
}</code></pre>
<p>};</p>
<p>vector<Vertex> t(1);</p>
<p>void add_string(string const&amp; s) { int v = 0; for (char ch : s) { int c = ch - 'a'; if (t[v].next[c] == -1) { t[v].next[c] = t.size(); t.emplace_back(v, ch); } v = t[v].next[c]; } t[v].leaf = true; }</p>
<p>int go(int v, char ch);</p>
<p>int get_link(int v) { if (t[v].link == -1) { if (v == 0 || t[v].p == 0) t[v].link = 0; else t[v].link = go(get_link(t[v].p), t[v].pch); } return t[v].link; }</p>
<p>int go(int v, char ch) { int c = ch - 'a'; if (t[v].go[c] == -1) { if (t[v].next[c] != -1) t[v].go[c] = t[v].next[c]; else t[v].go[c] = v == 0 ? 0 : go(get_link(v), ch); } return t[v].go[c]; } ```</p>
<p>It is easy to see, that due to the memorization of the found suffix links and transitions the total time for finding all suffix links and transitions will be linear.</p>
<h2 id="applications">Applications</h2>
<h3 id="find-all-strings-from-a-given-set-in-a-text">Find all strings from a given set in a text</h3>
<p>Given a set of strings and a text. We have to print all occurrences of all strings from the set in the given text in <span class="math inline"><em>O</em>(len + ans)</span>, where <span class="math inline">len</span> is the length of the text and <span class="math inline">ans</span> is the size of the answer.</p>
<p>We construct an automaton for this set of strings. We will now process the text letter by letter, transitioning during the different states. Initially we are at the root of the trie. If we are at any time at state <span class="math inline"><em>v</em></span>, and the next letter is <span class="math inline"><em>c</em></span>, then we transition to the next state with <span class="math inline">go(<em>v</em>, <em>c</em>)</span>, thereby either increasing the length of the current match substring by <span class="math inline">1</span>, or decreasing it by following a suffix link.</p>
<p>How can we find out for a state <span class="math inline"><em>v</em></span>, if there are any matches with strings for the set? First, it is clear that if we stand on a <span class="math inline">leaf</span> vertex, then then string corresponding to the vertex ends at this position in the text. However this is by no means the only possible case of achieving a match: if we can reach one or more <span class="math inline">leaf</span> vertices by moving along the suffix links, then there will be also a match corresponding to each found <span class="math inline">leaf</span> vertex. A simple example demonstrating this situation can be creating using the set of strings <span class="math inline">$\\{dabce, abc, bc\\}$</span> and the text <span class="math inline"><em>d</em><em>a</em><em>b</em><em>c</em></span>.</p>
<p>Thus if we store in each <span class="math inline">leaf</span> vertex the index of the string corresponding to it (or the list of indices if duplicate strings appear in the set), then we can find in <span class="math inline"><em>O</em>(<em>n</em>)</span> time the indices of all strings which match the current state, by simply following the suffix links from the current vertex to the root. However this is not the most efficient solution, since this gives us <span class="math inline"><em>O</em>(<em>n</em> len)</span> complexity in total. However this can be optimized by computing and storing the nearest <span class="math inline">leaf</span> vertex that is reachable using suffix links (this is sometimes called the <strong>exit link</strong>). This value we can compute lazily in linear time. Thus for each vertex we can advance in <span class="math inline"><em>O</em>(1)</span> time to the next marked vertex in the suffix link path, i.e. to the next match. Thus for each match we spend <span class="math inline"><em>O</em>(1)</span> time, and therefore we reach the complexity <span class="math inline"><em>O</em>(len + ans)</span>.</p>
<p>If you only want to count the occurrences and not find the indices themselves, you can calculate the number of marked vertices in the suffix link path for each vertex <span class="math inline"><em>v</em></span>. This can be calculated in <span class="math inline"><em>O</em>(<em>n</em>)</span> time in total. Thus we can sum up all matches in <span class="math inline"><em>O</em>(len)</span>.</p>
<h3 id="finding-the-lexicographical-smallest-string-of-a-given-length-that-doesnt-match-any-given-strings">Finding the lexicographical smallest string of a given length that doesn't match any given strings</h3>
<p>A set of strings and a length <span class="math inline"><em>L</em></span> is given. We have to find a string of length <span class="math inline"><em>L</em></span>, which does not contain any of the string, and derive the lexicographical smallest of such strings.</p>
<p>We can construct the automaton for the set of strings. Let's remember, that the vertices from which we can reach a <span class="math inline">leaf</span> vertex are the states, at which we have a match with a string from the set. Since in this task we have to avoid matches, we are not allowed to enter such states. On the other hand we can enter all other vertices. Thus we delete all &quot;bad&quot; vertices from the machine, and in the remaining graph of the automaton we find the lexicographical smallest path of length <span class="math inline"><em>L</em></span>. This task can be solved in <span class="math inline"><em>O</em>(<em>L</em>)</span> for example by <a href="./graph/depth-first-search.html">depth first search</a>.</p>
<h3 id="finding-the-shortest-string-containing-all-given-strings">Finding the shortest string containing all given strings</h3>
<p>Here we use the same ideas. For each vertex we store a mask that denotes the strings which match at this state. Then the problem can be reformulated as follows: initially being in the state <span class="math inline">(<em>v</em> = root,  mask = 0)</span>, we want to reach the state <span class="math inline">(<em>v</em>,  mask = 2<sup><em>n</em></sup> − 1)</span>, where <span class="math inline"><em>n</em></span> is the number of strings in the set. When we transition from one state to another using a letter, we update the mask accordingly. By running a <a href="./graph/breadth-first-search.html">breath first search</a> we can find a path to the state <span class="math inline">(<em>v</em>,  mask = 2<sup><em>n</em></sup> − 1)</span> with the smallest length.</p>
<h3 id="finding-the-lexicographical-smallest-string-of-length-l-containing-k-strings">Finding the lexicographical smallest string of length <span class="math inline"><em>L</em></span> containing <span class="math inline"><em>k</em></span> strings</h3>
<p>As in the previous problem, we calculate for each vertex the number of matches that correspond to it (that is the number of marked vertices reachable using suffix links). We reformulate the problem: the current state is determined by a triple of numbers <span class="math inline">(<em>v</em>,  len,  cnt)</span>, and we want to reach from the state <span class="math inline">(root,  0,  0)</span> the state <span class="math inline">(<em>v</em>,  <em>L</em>,  <em>k</em>)</span>, where <span class="math inline"><em>v</em></span> can be any vertex. Thus we can find such a path using depth first search (and if the search looks at the edges in their natural order, then the found path will automatically be the lexicographical smallest).</p>
<h2 id="problems">Problems</h2>
<ul>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2637">UVA #11590 - Prefix Lookup</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2112">UVA #11171 - SMS</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=1620">UVA #10679 - I Love Strings!!</a></li>
<li><a href="http://codeforces.com/problemset/problem/963/D">Codeforces - Frequency of String</a></li>
</ul>
</body>
</html>
