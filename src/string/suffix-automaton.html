<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body>
<!--?title Suffix Automaton -->
<h1 id="suffix-automaton">Suffix Automaton</h1>
<p>A <strong>suffix automaton</strong> is a powerful data structure that allows solving many string-related problems.</p>
<p>For example, you can search for all occurrences of one string in another, or count the amount of different substrings of a given string. Both tasks can be solved in linear time with the help of a suffix automaton.</p>
<p>Intuitively a suffix automaton can be understood as compressed form of <strong>all substrings</strong> of a given string. An impressive fact is, that the suffix automaton contains all this information in a highly compressed form. For a string of length <span class="math inline"><em>n</em></span> it only requires <span class="math inline"><em>O</em>(<em>n</em>)</span> memory. Moreover, it can also be build in <span class="math inline"><em>O</em>(<em>n</em>)</span> time (if we consider the size <span class="math inline"><em>k</em></span> of the alphabet as a constant), otherwise both the memory and the time complexity will be <span class="math inline"><em>O</em>(<em>n</em>log<em>k</em>)</span>.</p>
<p>The linearity of the size of the suffix automaton was first discovered in 1983 by Blumer et al., and in 1985 the first linear algorithms for the construction was presented by Crochemore and Blumer.</p>
<h2 id="definition-of-a-suffix-automaton">Definition of a suffix automaton</h2>
<p>A suffix automaton for a given string <span class="math inline"><em>s</em></span> is a minimal <strong>DFA</strong> (deterministic finite automaton / deterministic finite state machine) that accepts all the suffixes of the string <span class="math inline"><em>s</em></span>.</p>
<p>In other words:</p>
<ul>
<li>A suffix automaton is an oriented acyclic graph. The vertices are called <strong>states</strong>, and the edges are called <strong>transitions</strong> between states.</li>
<li>One of the states <span class="math inline"><em>t</em><sub>0</sub></span> is the <strong>initial state</strong>, and it must be the source of the graph (all other states are reachable from <span class="math inline"><em>t</em><sub>0</sub></span>).</li>
<li>Each <strong>transition</strong> is labeled with some character. All transitions originating from a state must have <strong>different</strong> labels.</li>
<li>One or multiple states are marked as <strong>terminal states</strong>. If we start from the initial state <span class="math inline"><em>t</em><sub>0</sub></span> and move along transitions to a terminal state, then the labels of the passed transitions must spell one of the suffixes of the string <span class="math inline"><em>s</em></span>. Each of the suffixes of <span class="math inline"><em>s</em></span> must be spellable using a path from <span class="math inline"><em>t</em><sub>0</sub></span> to a terminal state.</li>
<li>The suffix automaton contains the minimum number of vertices among all automata satisfying the conditions described above.</li>
</ul>
<h3 id="substring-property">Substring property</h3>
<p>The simplest and most important property of a suffix automaton is, that it contains information about all substrings of the string <span class="math inline"><em>s</em></span>. Any path starting at the initial state <span class="math inline"><em>t</em><sub>0</sub></span>, if we write down the labels of the transitions, forms a <strong>substring</strong> of <span class="math inline"><em>s</em></span>. And conversely every substring of <span class="math inline"><em>s</em></span> corresponds to a certain path starting at <span class="math inline"><em>t</em><sub>0</sub></span>.</p>
<p>In order to simplify the explanations, we will say that the substrings <strong>corresponds</strong> to that path (starting at <span class="math inline"><em>t</em><sub>0</sub></span> and the labels spell the substring). And conversely we say that any path <strong>corresponds</strong> to the string spelled by its labels.</p>
<p>One or multiple paths can lead to a state. Thus, we will say that a state <strong>corresponds</strong> to the set of strings, which correspond to these paths.</p>
<h3 id="examples-of-constructed-suffix-automata">Examples of constructed suffix automata</h3>
<p>Here we will show some examples of suffix automata for several simple strings.</p>
<p>We will denote the initial state with blue and the terminal states with green.</p>
<p>For the string <span class="math inline">$s =~ &quot;&quot;$</span>:</p>
<div class="figure">
<img src="&amp;imgroot&amp;/SA.png" alt="Suffix automaton for &quot;&quot;" />
<p class="caption">Suffix automaton for &quot;&quot;</p>
</div>
<p>For the string <span class="math inline">$s =~ &quot;a&quot;$</span>:</p>
<div class="figure">
<img src="&amp;imgroot&amp;/SAa.png" alt="Suffix automaton for &quot;a&quot;" />
<p class="caption">Suffix automaton for &quot;a&quot;</p>
</div>
<p>For the string <span class="math inline">$s =~ &quot;aa&quot;$</span>:</p>
<div class="figure">
<img src="&amp;imgroot&amp;/SAaa.png" alt="Suffix automaton for &quot;aa&quot;" />
<p class="caption">Suffix automaton for &quot;aa&quot;</p>
</div>
<p>For the string <span class="math inline">$s =~ &quot;ab&quot;$</span>:</p>
<div class="figure">
<img src="&amp;imgroot&amp;/SAab.png" alt="Suffix automaton for &quot;ab&quot;" />
<p class="caption">Suffix automaton for &quot;ab&quot;</p>
</div>
<p>For the string <span class="math inline">$s =~ &quot;aba&quot;$</span>:</p>
<div class="figure">
<img src="&amp;imgroot&amp;/SAaba.png" alt="Suffix automaton for &quot;aba&quot;" />
<p class="caption">Suffix automaton for &quot;aba&quot;</p>
</div>
<p>For the string <span class="math inline">$s =~ &quot;abb&quot;$</span>:</p>
<div class="figure">
<img src="&amp;imgroot&amp;/SAabb.png" alt="Suffix automaton for &quot;abb&quot;" />
<p class="caption">Suffix automaton for &quot;abb&quot;</p>
</div>
<p>For the string <span class="math inline">$s =~ &quot;abbb&quot;$</span>:</p>
<div class="figure">
<img src="&amp;imgroot&amp;/SAabbb.png" alt="Suffix automaton for &quot;abbb&quot;" />
<p class="caption">Suffix automaton for &quot;abbb&quot;</p>
</div>
<h2 id="construction-in-linear-time">Construction in linear time</h2>
<p>Before we describe the algorithm to construct a suffix automaton in linear time, we need to introduce several new concepts and simple proofs, which will be very important in understanding the construction.</p>
<h3 id="end-positions-endpos">End positions <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span></h3>
<p>Consider any non-empty substring <span class="math inline"><em>t</em></span> of the string <span class="math inline"><em>s</em></span>. We will denote with <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em>(<em>t</em>)</span> the set of all positions in the string <span class="math inline"><em>s</em></span>, in which the occurrences of <span class="math inline"><em>t</em></span> end. For instance, we have <span class="math inline">$endpos(&quot;bc&quot;) = \{2, 4\}$</span> for the string <span class="math inline">$&quot;abcbc&quot;$</span>.</p>
<p>We will call two substrings <span class="math inline"><em>t</em><sub>1</sub></span> and <span class="math inline"><em>t</em><sub>2</sub></span> <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span>-equivalent, if their ending sets coincide: <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em>(<em>t</em><sub>1</sub>)=<em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em>(<em>t</em><sub>2</sub>)</span>. Thus all non-empty substrings of the string <span class="math inline"><em>s</em></span> can be decomposed into several <strong>equivalence classes</strong> according to their sets <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span>.</p>
<p>It turns out, that in a suffix machine <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span>-equivalent substrings <strong>correspond to the same state</strong>. In other words the number of states in a suffix automaton is equal to the number of equivalence classes among all substrings, plus the initial state. Each state of a suffix automaton corresponds to one or more substrings having the same value <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span>.</p>
<p>We will later describe the construction algorithm using this assumption. We will then see, that all the required properties of a suffix automaton, except for the minimality, are fulfilled. And the minimality follows from Nerode's theorem (which will not be proven in this article).</p>
<p>We can make some important observations concerning the values <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span>:</p>
<p><strong>Lemma 1</strong>: Two non-empty substrings <span class="math inline"><em>u</em></span> and <span class="math inline"><em>w</em></span> (with <span class="math inline"><em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>u</em>)≤<em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>w</em>)</span>) are <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span>-equivalent, if and only if the string <span class="math inline"><em>u</em></span> occurs in <span class="math inline"><em>s</em></span> only in the form of a suffix of <span class="math inline"><em>w</em></span>.</p>
<p>The proof is obvious. If <span class="math inline"><em>u</em></span> and <span class="math inline"><em>w</em></span> have the same <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span> values, then <span class="math inline"><em>u</em></span> is a suffix of <span class="math inline"><em>w</em></span> and appears only in the form of a suffix of <span class="math inline"><em>w</em></span> in <span class="math inline"><em>s</em></span>. And if <span class="math inline"><em>u</em></span> is a suffix of <span class="math inline"><em>w</em></span> and appears only in the form as a suffix in <span class="math inline"><em>s</em></span>, then the values <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span> are equal by definition.</p>
<p><strong>Lemma 2</strong>: Consider two non-empty substrings <span class="math inline"><em>u</em></span> and <span class="math inline"><em>w</em></span> (with <span class="math inline"><em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>u</em>)≤<em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>w</em>)</span>). Then their sets <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span> either don't intersect at all, or <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em>(<em>w</em>)</span> is a subset of <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em>(<em>u</em>)</span>. And it depends on if <span class="math inline"><em>u</em></span> is a suffix of <span class="math inline"><em>w</em></span> or not.</p>
<p><br /><span class="math display">$$\begin{cases}
endpos(w) \subseteq endpos(u) &amp; \text{if } u \text{ is a suffix of } w \\\\
endpos(w) \cap endpos(u) = \emptyset &amp; \text{otherwise}
\end{cases}$$</span><br /></p>
<p>Proof: If the sets <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em>(<em>u</em>)</span> and <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em>(<em>w</em>)</span> have at least one common element, then the strings <span class="math inline"><em>u</em></span> and <span class="math inline"><em>w</em></span> both end in that position, i.e. <span class="math inline"><em>u</em></span> is a suffix of <span class="math inline"><em>w</em></span>. But then at every occurrence of <span class="math inline"><em>w</em></span> also appears the substring <span class="math inline"><em>u</em></span>, which means that <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em>(<em>w</em>)</span> is a subset of <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em>(<em>u</em>)</span>.</p>
<p><strong>Lemma 3</strong>: Consider an <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span>-equivalence class. Sort all the substrings in this class by non-increasing length. Then in the resulting sequence each substring will be one shorter than the previous one, and at the same time will be a suffix of the previous one. In other words the substrings in the same equivalence class are actually each others suffixes, and take all possible lengths in a certain interval <span class="math inline">[<em>x</em>; <em>y</em>]</span>.</p>
<p>Proof: Fix come <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span>-equivalent class. If it only contains one string, then the lemma is obviously true. Now let's say that the number of strings in the class is greater than one.</p>
<p>According to Lemma 1, two different <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span>-equivalent strings are always in such a way, that the shorter one is a proper suffix of the longer one. Consequently, there cannot be two strings of the same length in the equivalence class.</p>
<p>Let's denote by <span class="math inline"><em>w</em></span> the longest, and through <span class="math inline"><em>u</em></span> the shortest string in the equivalence class. According to Lemma 1, the string <span class="math inline"><em>u</em></span> is a proper suffix of the string <span class="math inline"><em>w</em></span>. Consider now any suffix of <span class="math inline"><em>w</em></span> with a length in the interval <span class="math inline">[<em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>u</em>);<em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>w</em>)]</span>. It is easy to see, that this suffix is also contained in the same equivalence class. Because this suffix can only appear in the form of a suffix of <span class="math inline"><em>w</em></span> in the string <span class="math inline"><em>s</em></span> (since also the shorter suffix <span class="math inline"><em>u</em></span> occurs in <span class="math inline"><em>s</em></span> only in the form of a suffix of <span class="math inline"><em>w</em></span>). Consequently, according to Lemma 1, this suffix is <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span>-equivalent to the string <span class="math inline"><em>w</em></span>.</p>
<h3 id="suffix-links-link">Suffix links <span class="math inline"><em>l</em><em>i</em><em>n</em><em>k</em></span></h3>
<p>Consider some state <span class="math inline"><em>v</em> ≠ <em>t</em><sub>0</sub></span> in the automaton. As we know, the state <span class="math inline"><em>v</em></span> corresponds to the class of strings with the same <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span> values. And if we denote by <span class="math inline"><em>w</em></span> the longest of these strings, then all the other strings are suffixes of <span class="math inline"><em>w</em></span>.</p>
<p>We also know the first few suffixes of a string <span class="math inline"><em>w</em></span> (if we consider suffixes in descending order of their length) are all contained in this equivalent class, and all other suffixes (at least one other - the empty suffix) are in some other classes. We denote by <span class="math inline"><em>t</em></span> the biggest such suffix, and make a suffix link to it.</p>
<p>In other words, a <strong>suffix link</strong> <span class="math inline"><em>l</em><em>i</em><em>n</em><em>k</em>(<em>v</em>)</span> leads to the state that corresponds to the <strong>longest suffix</strong> of <span class="math inline"><em>w</em></span> that is another <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span>-equivalent class.</p>
<p>Here we assume that the initial state <span class="math inline"><em>t</em><sub>0</sub></span> corresponds to its own equivalence class (containing only the empty string), and for convenience we set <span class="math inline">$endpos(t) = \\{-1, 0, \dots, length(s)-1\\}$</span>.</p>
<p><strong>Lemma 4</strong>: Suffix links form a <strong>tree</strong> with the root <span class="math inline"><em>t</em><sub>0</sub></span>.</p>
<p>Proof: Consider an arbitrary state <span class="math inline"><em>v</em> ≠ <em>t</em><sub>0</sub></span>. A suffix link <span class="math inline"><em>l</em><em>i</em><em>n</em><em>k</em>(<em>v</em>)</span> leads to a state corresponding to strings with strictly smaller length (this follows from the definition of the suffix links and from Lemma 3). Therefore, by moving along the suffix links, we will sooner or later come to the initial state <span class="math inline"><em>t</em><sub>0</sub></span>, which corresponds to the empty string.</p>
<p><strong>Lemma 5</strong>: If we construct a tree using the sets <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span> (by the rule that the set of a parent node contains the sets of all children as subsets), then the structure will coincide with the tree of suffix links.</p>
<p>Proof: The fact that we can construct a tree using the sets <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span> follows directly from Lemma 2 (that any two sets either do not intersect of one is contained in the other).</p>
<p>Let us now consider an arbitrary state <span class="math inline"><em>v</em> ≠ <em>t</em><sub>0</sub></span>, and its suffix link <span class="math inline"><em>l</em><em>i</em><em>n</em><em>k</em>(<em>v</em>)</span>. From the definition of the suffix link and from Lemma 2 it follows that <br /><span class="math display"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em>(<em>v</em>)⊆<em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em>(<em>l</em><em>i</em><em>n</em><em>k</em>(<em>v</em>)), </span><br /> which together with with the previous lemma proves the assertion: the tree of suffix links is essentially a tree of sets <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span>.</p>
<p>Here is an <strong>example</strong> of a tree of suffix links in the suffix automaton build for the string <span class="math inline">$&quot;abcbc&quot;$</span>. The nodes are labeled with the longest substring from the corresponding equivalence class.</p>
<div class="figure">
<img src="&amp;imgroot&amp;/SA_suffix_links.png" alt="Suffix automaton for &quot;abcbc&quot; with suffix links" />
<p class="caption">Suffix automaton for &quot;abcbc&quot; with suffix links</p>
</div>
<h3 id="recap">Recap</h3>
<p>Before proceeding to the algorithm itself, we recap the accumulated knowledge, and introduce a few auxiliary notations.</p>
<ul>
<li>The substrings of the string <span class="math inline"><em>s</em></span> can be decomposed into equivalence classes according to their end positions <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span>.</li>
<li>The suffix automaton consists of the initial state <span class="math inline"><em>t</em><sub>0</sub></span>, as well as of one state for each <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span>-equivalence class.</li>
<li>For each state <span class="math inline"><em>v</em></span> one or multiple substrings match. We denote by <span class="math inline"><em>l</em><em>o</em><em>n</em><em>g</em><em>e</em><em>s</em><em>t</em>(<em>v</em>)</span> the longest such string, and through <span class="math inline"><em>l</em><em>e</em><em>n</em>(<em>v</em>)</span> its length. We denote by <span class="math inline"><em>s</em><em>h</em><em>o</em><em>r</em><em>t</em><em>e</em><em>s</em><em>t</em>(<em>v</em>)</span> the shortest such substring, and its length with <span class="math inline"><em>m</em><em>i</em><em>n</em><em>l</em><em>e</em><em>n</em>(<em>v</em>)</span>. Then all the strings corresponding to this state are different suffixes of the string <span class="math inline"><em>l</em><em>o</em><em>n</em><em>g</em><em>e</em><em>s</em><em>t</em>(<em>v</em>)</span> and have all possible lengths in the interval <span class="math inline">[<em>m</em><em>i</em><em>n</em><em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>v</em>);<em>l</em><em>e</em><em>n</em>(<em>v</em>)]</span>.</li>
<li>For each state <span class="math inline"><em>v</em> ≠ <em>t</em><sub>0</sub></span> a suffix link is defined as a link, that leads to a state that corresponds to the suffix of the string <span class="math inline"><em>l</em><em>o</em><em>n</em><em>g</em><em>e</em><em>s</em><em>t</em>(<em>v</em>)</span> of length <span class="math inline"><em>m</em><em>i</em><em>n</em><em>l</em><em>e</em><em>n</em>(<em>v</em>)−1</span>. The suffix links form a tree with the root in <span class="math inline"><em>t</em><sub>0</sub></span>, and at the same time this tree forms an inclusion relationship between the sets <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span>.</li>
<li>We can express <span class="math inline"><em>m</em><em>i</em><em>n</em><em>l</em><em>e</em><em>n</em>(<em>v</em>)</span> for <span class="math inline"><em>v</em> ≠ <em>t</em><sub>0</sub></span> using the suffix link <span class="math inline"><em>l</em><em>i</em><em>n</em><em>k</em>(<em>v</em>)</span> as: <br /><span class="math display"><em>m</em><em>i</em><em>n</em><em>l</em><em>e</em><em>n</em>(<em>v</em>)=<em>l</em><em>e</em><em>n</em>(<em>l</em><em>i</em><em>n</em><em>k</em>(<em>v</em>)) + 1</span><br /></li>
<li>If we start from an arbitrary state <span class="math inline"><em>v</em><sub>0</sub></span> and follow the suffix links, then sooner or later we will reach the initial state <span class="math inline"><em>t</em><sub>0</sub></span>. In this case we obtain a sequence of disjoint intervals <span class="math inline">[<em>m</em><em>i</em><em>n</em><em>l</em><em>e</em><em>n</em>(<em>v</em><sub><em>i</em></sub>);<em>l</em><em>e</em><em>n</em>(<em>v</em><sub><em>i</em></sub>)]</span>, which in union forms the continuous interval <span class="math inline">[0; <em>l</em><em>e</em><em>n</em>(<em>v</em><sub>0</sub>)]</span>.</li>
</ul>
<h3 id="algorithm">Algorithm</h3>
<p>Now we can proceed to the algorithm itself. The algorithm will be <strong>online</strong>, i.e. we will add the characters of the string one by one, and modify the automaton accordingly in each step.</p>
<p>To achieve linear memory consumption, we will only store the values <span class="math inline"><em>l</em><em>e</em><em>n</em></span>, <span class="math inline"><em>l</em><em>i</em><em>n</em><em>k</em></span> and a list of transitions in each state. We will not label terminal states (but we will later show how to arrange these labels after constructing the suffix automaton).</p>
<p>Initially the automaton consists of a single state <span class="math inline"><em>t</em><sub>0</sub></span>, which will be the index <span class="math inline">0</span> (the remaining states will receive the indices <span class="math inline">1, 2, …</span>). We assign it <span class="math inline"><em>l</em><em>e</em><em>n</em> = 0</span> and <span class="math inline"><em>l</em><em>i</em><em>n</em><em>k</em> = −1</span> for convenience (<span class="math inline">−1</span> will be a fictional, non-existing state).</p>
<p>Now the whole task boils down to implementing the process of <strong>adding one character</strong> <span class="math inline"><em>c</em></span> to the end of the current string. Let us describe this process:</p>
<ul>
<li>Let <span class="math inline"><em>l</em><em>a</em><em>s</em><em>t</em></span> be the state corresponding to the entire string before adding the character <span class="math inline"><em>c</em></span>. (Initially we set <span class="math inline"><em>l</em><em>a</em><em>s</em><em>t</em> = 0</span>, and we will change <span class="math inline"><em>l</em><em>a</em><em>s</em><em>t</em></span> in the last step of the algorithm accordingly.)</li>
<li>Create a new state <span class="math inline"><em>c</em><em>u</em><em>r</em></span>, and assign it with <span class="math inline"><em>l</em><em>e</em><em>n</em>(<em>c</em><em>u</em><em>r</em>)=<em>l</em><em>e</em><em>n</em>(<em>l</em><em>a</em><em>s</em><em>t</em>)+1</span>. The value <span class="math inline"><em>l</em><em>i</em><em>n</em><em>k</em>(<em>c</em><em>u</em><em>r</em>)</span> is not know at the time.</li>
<li>Now we to the following procedure: We start at the state <span class="math inline"><em>l</em><em>a</em><em>s</em><em>t</em></span>. While there isn't a transition through the letter <span class="math inline"><em>c</em></span>, we will add a transition to the state <span class="math inline"><em>c</em><em>u</em><em>r</em></span>, and follow the suffix link. If at some point there already exists a transition through the letter <span class="math inline"><em>c</em></span>, then we will stop and denote this state with <span class="math inline"><em>p</em></span>.</li>
<li>If it haven't found such a state <span class="math inline"><em>p</em></span>, then we reached the fictitious state <span class="math inline">−1</span>, then we can just assign <span class="math inline"><em>l</em><em>i</em><em>n</em><em>k</em>(<em>c</em><em>u</em><em>r</em>)=0</span> and leave.</li>
<li>Suppose now that we have found a state <span class="math inline"><em>p</em></span>, from which there exists a transition through the letter <span class="math inline"><em>c</em></span>. We will denote the state, to which the transition leads, with <span class="math inline"><em>q</em></span>.</li>
<li>Now we have two cases. Either <span class="math inline"><em>l</em><em>e</em><em>n</em>(<em>p</em>)+1 = <em>l</em><em>e</em><em>n</em>(<em>q</em>)</span>, or not.</li>
<li>If <span class="math inline"><em>l</em><em>e</em><em>n</em>(<em>p</em>)+1 = <em>l</em><em>e</em><em>n</em>(<em>q</em>)</span>, then we can simply assign <span class="math inline"><em>l</em><em>i</em><em>n</em><em>k</em>(<em>c</em><em>u</em><em>r</em>)=<em>q</em></span> and leave.</li>
<li><p>Otherwise it is a bit more complicated. It is necessary to <strong>clone</strong> the state <span class="math inline"><em>q</em></span>: we create a new state <span class="math inline"><em>c</em><em>l</em><em>o</em><em>n</em><em>e</em></span>, copy all the data from <span class="math inline"><em>q</em></span> (suffix link and transition) except the value <span class="math inline"><em>l</em><em>e</em><em>n</em></span>. We will assign <span class="math inline"><em>l</em><em>e</em><em>n</em>(<em>c</em><em>l</em><em>o</em><em>n</em><em>e</em>)=<em>l</em><em>e</em><em>n</em>(<em>p</em>)+1</span>.</p>
<p>After cloning we direct the suffix link from <span class="math inline"><em>c</em><em>u</em><em>r</em></span> to <span class="math inline"><em>c</em><em>l</em><em>o</em><em>n</em><em>e</em></span>, and also from <span class="math inline"><em>q</em></span> to clone.</p>
Finally we need to walk from the state <span class="math inline"><em>p</em></span> back using suffix links as long as there is a transition through <span class="math inline"><em>c</em></span> to the state <span class="math inline"><em>q</em></span>, and redirect all those to the state <span class="math inline"><em>c</em><em>l</em><em>o</em><em>n</em><em>e</em></span>.</li>
<li><p>In any of the three cases, after completing the procedure, we update the value <span class="math inline"><em>l</em><em>a</em><em>s</em><em>t</em></span> with the state <span class="math inline"><em>c</em><em>u</em><em>r</em></span>.</p></li>
</ul>
<p>If we also want to know which states are <strong>terminal</strong> and which are not, the we can find all terminal states after constructing the complete suffix automaton for the entire string <span class="math inline"><em>s</em></span>. To do this, we take the state corresponding to the entire string (stored in the variable <span class="math inline"><em>l</em><em>a</em><em>s</em><em>t</em></span>), and follow its suffix links until we reach the initial state. We will mark all visited states as terminal. It is easy to understand that by doing so we will mark exactly the states corresponding to all the suffixes of the string <span class="math inline"><em>s</em></span>, which are exactly the terminal states.</p>
<p>In the next section we will look in detail at each step and show its <strong>correctness</strong>.</p>
<p>Here we only note that, since we only create one or two new states for each character of <span class="math inline"><em>s</em></span>, the suffix automaton contains a <strong>linear number of states</strong>.</p>
<p>The linearity of the number of transitions, and in general the linearity of the runtime of the algorithm is less clear, and they will be proven after we proved the correctness.</p>
<h3 id="correctness">Correctness</h3>
<ul>
<li><p>We will call a transition <span class="math inline">(<em>p</em>, <em>q</em>)</span> <strong>continuous</strong> if <span class="math inline"><em>l</em><em>e</em><em>n</em>(<em>p</em>)+1 = <em>l</em><em>e</em><em>n</em>(<em>q</em>)</span>. Otherwise, i.e. when <span class="math inline"><em>l</em><em>e</em><em>n</em>(<em>p</em>)+1 &lt; <em>l</em><em>e</em><em>n</em>(<em>q</em>)</span>, the transition will be called <strong>non-continuous</strong>.</p>
<p>As we can see from the description of the algorithm, continuous and non-continuous transitions will lead to different cases of the algorithm. Continuous transitions are fixed, and will never change again. In contrast non-continuous transition may change, when new letters are added to the string (the end of the transition edge may change).</p></li>
<li><p>To avoid ambiguity we will denote the string, for which the suffix automaton was built before adding the current character <span class="math inline"><em>c</em></span>, with <span class="math inline"><em>s</em></span>.</p></li>
<li><p>The algorithm begins with creating a new state <span class="math inline"><em>c</em><em>u</em><em>r</em></span>, which will correspond to the entire string <span class="math inline"><em>s</em> + <em>c</em></span>. It is clear why we have to create a new state. Together with the new character a new equivalence class is created.</p></li>
<li><p>After creating a new state we traverse by suffix links starting from the state corresponding to the entire string <span class="math inline"><em>s</em></span>. For each state we try to add a transition with the character <span class="math inline"><em>c</em></span> to the new state <span class="math inline"><em>c</em><em>u</em><em>r</em></span>. Thus we append to each suffix of <span class="math inline"><em>s</em></span> the character <span class="math inline"><em>c</em></span>. However we can only add these new transitions, if they don't conflict with an already existing one. Therefore as soon as we find an already existing transition with <span class="math inline"><em>c</em></span> we have to stop.</p></li>
<li><p>In the simplest case we reached the fictitious state <span class="math inline">−1</span>. This means we added the transition with <span class="math inline"><em>c</em></span> to all suffixes of <span class="math inline"><em>s</em></span>. This also means, that the character <span class="math inline"><em>c</em></span> hasn't been part of the string <span class="math inline"><em>s</em></span> before. Therefore the suffix link of <span class="math inline"><em>c</em><em>u</em><em>r</em></span> has to lead to the state <span class="math inline">0</span>.</p></li>
<li><p>In the second case we came across an existing transition <span class="math inline">(<em>p</em>, <em>q</em>)</span>. This means that we tried to add a string <span class="math inline"><em>x</em> + <em>c</em></span> (where <span class="math inline"><em>x</em></span> is a suffix of <span class="math inline"><em>s</em></span>) to the machine that <strong>already exists</strong> in the machine (the string <span class="math inline"><em>x</em> + <em>c</em></span> already appears as a substring of <span class="math inline"><em>s</em></span>). Since we assume that the automaton for the string <span class="math inline"><em>s</em></span> is build correctly, we should not add a new transition here.</p>
<p>However there is a difficulty. To which state should the suffix link from the state <span class="math inline"><em>c</em><em>u</em><em>r</em></span> lead? We have to make a suffix link to a state, in which the longest string is exactly <span class="math inline"><em>x</em> + <em>c</em></span>, i.e. the <span class="math inline"><em>l</em><em>e</em><em>n</em></span> of this state should be <span class="math inline"><em>l</em><em>e</em><em>n</em>(<em>p</em>)+1</span>. However it is possible, that such a state doesn't yet exists, i.e. <span class="math inline"><em>l</em><em>e</em><em>n</em>(<em>q</em>)&gt;<em>l</em><em>e</em><em>n</em>(<em>p</em>)+1</span>. In this case we have to create such a state, by <strong>splitting</strong> the state <span class="math inline"><em>q</em></span>.</p></li>
<li><p>If the transition <span class="math inline">(<em>p</em>, <em>q</em>)</span> turns out to be continuous, then <span class="math inline"><em>l</em><em>e</em><em>n</em>(<em>q</em>)=<em>l</em><em>e</em><em>n</em>(<em>p</em>)+1</span>. In this case everything is simple. We direct the suffix link from <span class="math inline"><em>c</em><em>u</em><em>r</em></span> to the state <span class="math inline"><em>q</em></span>.</p></li>
<li><p>Otherwise the transition is non-continuous, i.e. <span class="math inline"><em>l</em><em>e</em><em>n</em>(<em>q</em>)&gt;<em>l</em><em>e</em><em>n</em>(<em>p</em>)+1</span>. This means that the state <span class="math inline"><em>q</em></span> corresponds to not only the suffix of <span class="math inline"><em>s</em> + <em>c</em></span> with length <span class="math inline"><em>l</em><em>e</em><em>n</em>(<em>p</em>)+1</span>, but also to longer substrings of <span class="math inline"><em>s</em></span>. We can do nothing other than <strong>splitting</strong> the state <span class="math inline"><em>q</em></span> into two sub-states, so that the first one has length <span class="math inline"><em>l</em><em>e</em><em>n</em>(<em>p</em>)+1</span>.</p>
<p>How can we split a state? We <strong>clone</strong> the state <span class="math inline"><em>q</em></span>, which gives us the state <span class="math inline"><em>c</em><em>l</em><em>o</em><em>n</em><em>e</em></span>, and we set <span class="math inline"><em>l</em><em>e</em><em>n</em>(<em>c</em><em>l</em><em>o</em><em>n</em><em>e</em>)=<em>l</em><em>e</em><em>n</em>(<em>p</em>)+1</span>. We copy all the transitions from <span class="math inline"><em>q</em></span> to <span class="math inline"><em>c</em><em>l</em><em>o</em><em>n</em><em>e</em></span>, because we don't want to change the paths that traverse through <span class="math inline"><em>q</em></span>. Also we set the suffix link from <span class="math inline"><em>c</em><em>l</em><em>o</em><em>n</em><em>e</em></span> to the target of the suffix link of <span class="math inline"><em>q</em></span>, and set the suffix link of <span class="math inline"><em>q</em></span> to <span class="math inline"><em>c</em><em>l</em><em>o</em><em>n</em><em>e</em></span>.</p>
<p>And after splitting the state, we set the suffix link from <span class="math inline"><em>c</em><em>u</em><em>r</em></span> to <span class="math inline"><em>c</em><em>l</em><em>o</em><em>n</em><em>e</em></span>.</p>
<p>In the last step we change some of the transitions to <span class="math inline"><em>q</em></span>, we redirect them to <span class="math inline"><em>c</em><em>l</em><em>o</em><em>n</em><em>e</em></span>. Which transitions do we have to change? It is enough to redirect only the transitions corresponding to all the suffixes of the string <span class="math inline"><em>w</em> + <em>c</em></span> (where <span class="math inline"><em>w</em></span> is the longest string of <span class="math inline"><em>p</em></span>), i.e. we need to continue to move along the suffix links, starting from the vertex <span class="math inline"><em>p</em></span> until we reach the fictitious state <span class="math inline">−1</span> or a transition that leads to a different state than <span class="math inline"><em>q</em></span>.</p></li>
</ul>
<h3 id="linear-number-of-operations">Linear number of operations</h3>
<p>First we immediately make the assumption that the size of the alphabet is <strong>constant</strong>. If this is not the case, then it will not be possible to talk about the linear time complexity. The list of transitions from one vertex will be stored in a balanced tree, which allows you to quickly perform key search operations and adding keys. Therefore if we denote with <span class="math inline"><em>k</em></span> the size of the alphabet, then the asymptotic behavior of the algorithm will be <span class="math inline"><em>O</em>(<em>n</em>log<em>k</em>)</span> with <span class="math inline"><em>O</em>(<em>n</em>)</span> memory. However if the alphabet is small enough, then you can sacrifice memory by avoiding balanced trees, and store the transitions at each vertex as an array of length <span class="math inline"><em>k</em></span> (for quick searching by key) and a dynamic list (to quickly traverse all available keys). Thus we reach the <span class="math inline"><em>O</em>(<em>n</em>)</span> time complexity for the algorithm, but at a cost of <span class="math inline"><em>O</em>(<em>n</em><em>k</em>)</span> memory complexity.</p>
<p>So we will consider the size of the alphabet to be constant, i.e. each operation of searching for a transition on a character, adding a transition, searching for the next transition - all these operations can be done in <span class="math inline"><em>O</em>(1)</span>.</p>
<p>If we consider all parts of the algorithm, then it contains three places in the algorithm in which the linear complexity is not obvious:</p>
<ul>
<li>The first place is the traversal through the suffix links from the state <span class="math inline"><em>l</em><em>a</em><em>s</em><em>t</em></span>, adding transitions with the character <span class="math inline"><em>c</em></span>.</li>
<li>The second place is the copying of transitions when the state <span class="math inline"><em>q</em></span> is cloned into a new state <span class="math inline"><em>c</em><em>l</em><em>o</em><em>n</em><em>e</em></span>.</li>
<li>Third place is changing the transition leading to <span class="math inline"><em>q</em></span>, redirecting them to <span class="math inline"><em>c</em><em>l</em><em>o</em><em>n</em><em>e</em></span>.</li>
</ul>
<p>We use the fact that the size of the suffix automaton (both in number of states and in the number of transitions) is <strong>linear</strong>. (The proof of the linearity of the number of states is the algorithm itself, and the proof of linearity of the number of states is given below, after the implementation of the algorithm).</p>
<p>Thus the total complexity of the <strong>first and second places</strong> is obvious, after all each operation adds only one amortized new transition to the automaton.</p>
<p>It remains to estimate the total complexity of the <strong>third place</strong>, in which we redirect transitions, that pointed originally to <span class="math inline"><em>q</em></span>, to <span class="math inline"><em>c</em><em>l</em><em>o</em><em>n</em><em>e</em></span>. We denote <span class="math inline"><em>v</em> = <em>l</em><em>o</em><em>n</em><em>g</em><em>e</em><em>s</em><em>t</em>(<em>p</em>)</span>. This is a suffix of the string <span class="math inline"><em>s</em></span>, and with each iteration its length decreases - and therefore the position <span class="math inline"><em>v</em></span> as the suffix of the string <span class="math inline"><em>s</em></span> increases monotonically with each iteration. In this case, if before the first iteration of the loop, the corresponding string <span class="math inline"><em>v</em></span> was at the depth <span class="math inline"><em>k</em></span> (<span class="math inline"><em>k</em> ≥ 2</span>) from <span class="math inline"><em>l</em><em>a</em><em>s</em><em>t</em></span> (by counting the depth as the number of suffix links), then after the last iteration the string <span class="math inline"><em>v</em> + <em>c</em></span> will be a <span class="math inline">2</span>-th suffix link on the path from <span class="math inline"><em>c</em><em>u</em><em>r</em></span> (which will become the new value <span class="math inline"><em>l</em><em>a</em><em>s</em><em>t</em></span>).</p>
<p>Thus, each iteration of this loop leads to the fact that the position of the string <span class="math inline"><em>l</em><em>o</em><em>n</em><em>g</em><em>e</em><em>s</em><em>t</em>(<em>l</em><em>i</em><em>n</em><em>k</em>(<em>l</em><em>i</em><em>n</em><em>k</em>(<em>l</em><em>a</em><em>s</em><em>t</em>))</span> as suffix of the current string will monotonically increase. Therefore this cycle cannot be executed more than <span class="math inline"><em>n</em></span> iterations, which was required to prove.</p>
<h3 id="implementation">Implementation</h3>
<p>First we describe a data structure that will store all information about a specific transition (<span class="math inline"><em>l</em><em>e</em><em>n</em></span>, <span class="math inline"><em>l</em><em>i</em><em>n</em><em>k</em></span> and the list of transitions). If necessary you can add a terminal flag here, as well as other information. We will store the list of transitions in the form of a <span class="math inline"><em>m</em><em>a</em><em>p</em></span>, which allows us to achieve total <span class="math inline"><em>O</em>(<em>n</em>)</span> memory and <span class="math inline"><em>O</em>(<em>n</em>log<em>k</em>)</span> time for processing the entire string.</p>
<p><code>cpp suffix_automaton_struct struct state {     int len, link;     map&lt;char, int&gt; next; };</code></p>
<p>The suffix automaton itself will be stored in an array of these structures <span class="math inline"><em>s</em><em>t</em><em>a</em><em>t</em><em>e</em></span>. We store the current size <span class="math inline"><em>s</em><em>z</em></span> and also the variable <span class="math inline"><em>l</em><em>a</em><em>s</em><em>t</em></span>, the state corresponding to the entire string at the moment.</p>
<p><code>cpp suffix_automaton_def const int MAXLEN = 100000; state st[MAXLEN * 2]; int sz, last;</code></p>
<p>We give a function that initializes a suffix automaton (creating a suffix automaton with a single state).</p>
<p><code>cpp suffix_automaton_init void sa_init() {     st[0].len = 0;     st[0].link = -1;     sz++;     last = 0; }</code></p>
<p>And finally we give the implementation of the main function - which adds the next character to the end of the current line, rebuilding the machine accordingly.</p>
<p><code>cpp suffix_automaton_extend void sa_extend(char c) {     int cur = sz++;     st[cur].len = st[last].len + 1;     int p = last;     while (p != -1 &amp;&amp; !st[p].next.count(c)) {         st[p].next[c] = cur;         p = st[p].link;     }     if (p == -1) {         st[cur].link = 0;     } else {         int q = st[p].next[c];         if (st[p].len + 1 == st[q].len) {             st[cur].link = q;         } else {             int clone = sz++;             st[clone].len = st[p].len + 1;             st[clone].next = st[q].next;             st[clone].link = st[q].link;             while (p != -1 &amp;&amp; st[p].next[c] == q) {                 st[p].next[c] = clone;                 p = st[p].link;             }             st[q].link = st[cur].link = clone;         }     }     last = cur; }</code></p>
<p>As mentioned above, if you sacrifice memory (<span class="math inline"><em>O</em>(<em>n</em><em>k</em>)</span>, where <span class="math inline"><em>k</em></span> is the size of the alphabet), then you can achieve the build time of the machine in <span class="math inline"><em>O</em>(<em>n</em>)</span>, even for any alphabet size <span class="math inline"><em>k</em></span>. But for this you will have to store an array of size <span class="math inline"><em>k</em></span> in each state (for quickly jumping to the transition of the letter), and additional a list of all transitions (to quickly iterate over the transitions them).</p>
<h2 id="additional-properties">Additional properties</h2>
<h3 id="number-of-states">Number of states</h3>
<p>The number of states in a suffix automaton of the string <span class="math inline"><em>s</em></span> of length <span class="math inline"><em>n</em></span> <strong>doesn't exceed</strong> <span class="math inline">2<em>n</em> − 1</span> (for <span class="math inline"><em>n</em> ≥ 2</span>).</p>
<p>The proof is the construction algorithm itself, since initially the automaton consists of one state, and in the first and second iteration only a single state will be created, and in the remaining <span class="math inline"><em>n</em> − 2</span> steps at most <span class="math inline">2</span> states will be created each.</p>
<p>However we can also <strong>show</strong> this estimation <strong>without knowing the algorithm</strong>. Let us recall that the number of states is equal to the number of different sets <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span>. In addition theses sets <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span> form a tree (a parent vertex contains all children sets in his set). Consider this tree and transform it a little bit: as long as it has an internal vertex with only one child (which means that the set of the child misses at least one position from the parent set), we create a new child with the set of the missing positions. In the end we have a tree in which each inner vertex has a degree greater than one, and the number of leaves does not exceed <span class="math inline"><em>n</em></span>. Therefore there are no more than <span class="math inline">2<em>n</em> − 1</span> vertices in such a tree.</p>
<p>This bound of the number of states can actually be achieved for each <span class="math inline"><em>n</em></span>. A possible string is: <br /><span class="math display">$$&quot;abbb\dots bbb&quot;$$</span><br /> In each iteration, starting at the third one, the algorithm will split a state, resulting in exactly <span class="math inline">2<em>n</em> − 1</span> states.</p>
<h3 id="number-of-transitions">Number of transitions</h3>
<p>The number of transitions in a suffix automaton of a string <span class="math inline"><em>s</em></span> of length <span class="math inline"><em>n</em></span> <strong>doesn't exceed</strong> <span class="math inline">3<em>n</em> − 4</span> (for <span class="math inline"><em>n</em> ≥ 3</span>).</p>
<p>Let us prove this:</p>
<p>Let us first estimate the number of continuous transitions. Consider a spanning tree of the longest paths in the automaton starting in the state <span class="math inline"><em>t</em><sub>0</sub></span>. This skeleton will consist of only the continuous edges, and therefore their number is less than the number of states, i.e. it does not exceed <span class="math inline">2<em>n</em> − 2</span>.</p>
<p>Now let us estimate the number of non-continuous transitions. Let the current non-continuous transition be <span class="math inline">(<em>p</em>, <em>q</em>)</span> with the character <span class="math inline"><em>c</em></span>. We take the correspondent string <span class="math inline"><em>u</em> + <em>c</em> + <em>w</em></span>, where the string <span class="math inline"><em>u</em></span> corresponds to the longest path from the initial state to <span class="math inline"><em>p</em></span>, and <span class="math inline"><em>w</em></span> to the longest path from <span class="math inline"><em>q</em></span> to any terminal state. On one hand, each such string <span class="math inline"><em>u</em> + <em>c</em> + <em>w</em></span> for each incomplete strings will be different (since the strings <span class="math inline"><em>u</em></span> and <span class="math inline"><em>w</em></span> are formed only by complete transitions). On the other hand each such string <span class="math inline"><em>u</em> + <em>c</em> + <em>w</em></span>, by the definition of the terminal states, will be a suffix of the entire string <span class="math inline"><em>s</em></span>. Since there are only <span class="math inline"><em>n</em></span> non-empty suffixes of <span class="math inline"><em>s</em></span>, and non of the strings <span class="math inline"><em>u</em> + <em>c</em> + <em>w</em></span> can contain <span class="math inline"><em>s</em></span> (because the entire string only contains complete transitions), the total number of incomplete transitions does not exceed <span class="math inline"><em>n</em> − 1</span>.</p>
<p>Combining these two estimates gives us the bound <span class="math inline">3<em>n</em> − 3</span>. However, since the maximum number of states can only be achieved with the test case <span class="math inline">$&quot;abbb\dots bbb&quot;$</span> and this case has clearly less than <span class="math inline">3<em>n</em> − 3</span> transitions, we get the tighter bound of <span class="math inline">3<em>n</em> − 4</span> for the number of transitions in a suffix automaton.</p>
<p>This bound can also be achieved with the string: <br /><span class="math display">$$&quot;abbb\dots bbbc&quot;$$</span><br /></p>
<h2 id="applications">Applications</h2>
<p>Here we look at some tasks that can be solved using the suffix automaton. For the simplicity we assume that the alphabet size <span class="math inline"><em>k</em></span> is constant, which allows us to consider the complexity of appending a character and the traversal as constant.</p>
<h3 id="check-for-occurrence">Check for occurrence</h3>
<p>Given a text <span class="math inline"><em>T</em></span>, and multiple patters <span class="math inline"><em>P</em></span>. We have to check whether or not the strings <span class="math inline"><em>P</em></span> appear as a substring of <span class="math inline"><em>T</em></span>.</p>
<p>We build a suffix automaton of the text <span class="math inline"><em>T</em></span> in <span class="math inline"><em>O</em>(<em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>T</em>))</span> time. To check if a pattern <span class="math inline"><em>P</em></span> appears in <span class="math inline"><em>T</em></span>, we follow the transitions, starting from <span class="math inline"><em>t</em><sub>0</sub></span>, according to the characters of <span class="math inline"><em>P</em></span>. If at some point there doesn't exists a transition, then the pattern <span class="math inline"><em>P</em></span> doesn't appear as a substring of <span class="math inline"><em>T</em></span>. If we can process the entire string <span class="math inline"><em>P</em></span> this way, then the string appears in <span class="math inline"><em>T</em></span>.</p>
<p>It is clear that this will take <span class="math inline"><em>O</em>(<em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>P</em>))</span> time for each string <span class="math inline"><em>P</em></span>. Moreover the algorithm actually finds the length of the longest prefix of <span class="math inline"><em>P</em></span> that appears in the text.</p>
<h3 id="number-of-different-substrings">Number of different substrings</h3>
<p>Given a string <span class="math inline"><em>S</em></span>. You want to compute the number of different substrings.</p>
<p>Let us build a suffix automaton for the string <span class="math inline"><em>S</em></span>.</p>
<p>Each substring of <span class="math inline"><em>S</em></span> corresponds to some path in the automaton. Therefore the number of different substrings is equal to the number of different paths in the automaton starting at <span class="math inline"><em>t</em><sub>0</sub></span>.</p>
<p>Given that the suffix automaton is a directed acyclic graph, the number of different ways can be computed using dynamic programming.</p>
<p>Namely, let <span class="math inline"><em>d</em>[<em>v</em>]</span> be the number of ways, starting at the state <span class="math inline"><em>v</em></span> (including the path of length zero). Then we have the recursion: <br /><span class="math display"><em>d</em>[<em>v</em>]=1 + ∑<sub><em>w</em> : (<em>v</em>, <em>w</em>, <em>c</em>)∈<em>S</em><em>A</em></sub><em>d</em>[<em>w</em>]</span><br /> I.e. <span class="math inline"><em>d</em>[<em>v</em>]</span> can be expressed as the sum of answers for all ends of the transitions of <span class="math inline"><em>v</em></span>.</p>
<p>The number of different substrings is the value <span class="math inline"><em>d</em>[<em>t</em><sub>0</sub>]−1</span> (since we don't count the empty substring).</p>
<p>Total time complexity: <span class="math inline"><em>O</em>(<em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>S</em>))</span></p>
<h3 id="total-length-of-all-different-substrings">Total length of all different substrings</h3>
<p>Given a string <span class="math inline"><em>S</em></span>. We want to compute the total length of all its various substrings.</p>
<p>The solution is similar to the previous one, only now it is necessary to consider two quantities for the dynamic programming part: the number of different substrings <span class="math inline"><em>d</em>[<em>v</em>]</span> and their total length <span class="math inline"><em>a</em><em>n</em><em>s</em>[<em>v</em>]</span>.</p>
<p>We already described how to compute <span class="math inline"><em>d</em>[<em>v</em>]</span> in the previous task. The value <span class="math inline"><em>a</em><em>n</em><em>s</em>[<em>v</em>]</span> can be computed using the recursion: <br /><span class="math display"><em>a</em><em>n</em><em>s</em>[<em>v</em>]=∑<sub><em>w</em> : (<em>v</em>, <em>w</em>, <em>c</em>)∈<em>D</em><em>A</em><em>W</em><em>G</em></sub><em>d</em>[<em>w</em>]+<em>a</em><em>n</em><em>s</em>[<em>w</em>]</span><br /> We take the answer of each adjacent vertex <span class="math inline"><em>w</em></span>, and add to it <span class="math inline"><em>d</em>[<em>w</em>]</span> (since every substrings is one character longer when starting from the state <span class="math inline"><em>v</em></span>).</p>
<p>Again this task can be computed in <span class="math inline"><em>O</em>(<em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>S</em>))</span> time.</p>
<h3 id="lexicographically-k-th-substring">Lexicographically <span class="math inline"><em>k</em></span>-th substring</h3>
<p>Given a string <span class="math inline"><em>S</em></span>. We have to answer multiple queries. For each given number <span class="math inline"><em>K</em><sub><em>i</em></sub></span> we have to find the <span class="math inline"><em>K</em><sub><em>i</em></sub></span>-th string in the lexicographically ordered list of all substrings.</p>
<p>The solution of this problem is based on the idea of the previous two problems. The lexicographically <span class="math inline"><em>k</em></span>-th substring corresponds to the lexicographically <span class="math inline"><em>k</em></span>-th path in the suffix automaton. Therefore after counting the number of paths from each state, we can easily search for the <span class="math inline"><em>k</em></span>-th path starting from the root of the automaton.</p>
<p>This takes <span class="math inline"><em>O</em>(<em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>S</em>))</span> time for preprocessing and then <span class="math inline"><em>O</em>(<em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>a</em><em>n</em><em>s</em>)⋅<em>k</em>)</span> for each query (where <span class="math inline"><em>a</em><em>n</em><em>s</em></span> is the answer for the query and <span class="math inline"><em>k</em></span> is the size of the alphabet).</p>
<h3 id="smallest-cyclic-shift">Smallest cyclic shift</h3>
<p>Given a string <span class="math inline"><em>S</em></span>. We want to find the lexicographically smallest cyclic shift.</p>
<p>We construct a suffix automaton for the string <span class="math inline"><em>S</em> + <em>S</em></span>. Then the automaton will contain in itself as paths all the cyclic shifts of the string <span class="math inline"><em>S</em></span>.</p>
<p>Consequently the problem is reduced to finding the lexicographically smallest path of length <span class="math inline"><em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>S</em>)</span>, which can be done in a trivial way: we start in the initial state and greedily pass through the transitions with the minimal character.</p>
<p>Total time complexity is <span class="math inline"><em>O</em>(<em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>S</em>))</span>.</p>
<h3 id="number-of-occurrences">Number of occurrences</h3>
<p>For a given text <span class="math inline"><em>T</em></span>. We have to answer multiple queries. For each given pattern <span class="math inline"><em>P</em></span> we have to find out how many times the string <span class="math inline"><em>P</em></span> appears in the string <span class="math inline"><em>T</em></span> as substring.</p>
<p>We construct the suffix automaton for the text <span class="math inline"><em>T</em></span>.</p>
<p>Next we do the following preprocessing: for each state <span class="math inline"><em>v</em></span> in the automaton we calculate the number <span class="math inline"><em>c</em><em>n</em><em>t</em>[<em>v</em>]</span> that is equal to the size of the set <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em>(<em>v</em>)</span>. In fact all strings corresponding to the same state <span class="math inline"><em>v</em></span> appear in the text <span class="math inline"><em>T</em></span> an equal amount of times, which is equal to the number of positions in the set <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span>.</p>
<p>However we cannot construct the sets <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span> explicitly, therefore we only consider their sizes <span class="math inline"><em>c</em><em>n</em><em>t</em></span>.</p>
<p>To compute them we proceed as follows. For each state, if it was not created by cloning (and if it is not the initial state <span class="math inline"><em>t</em><sub>0</sub></span>), we initialize it with <span class="math inline"><em>c</em><em>n</em><em>t</em> = 1</span>. Then we will go through all states in decreasing order of their length <span class="math inline"><em>l</em><em>e</em><em>n</em></span>, and add the current value <span class="math inline"><em>c</em><em>n</em><em>t</em>[<em>v</em>]</span> to the suffix links: <br /><span class="math display"><em>c</em><em>n</em><em>t</em>[<em>l</em><em>i</em><em>n</em><em>k</em>(<em>v</em>)] += <em>c</em><em>n</em><em>t</em>[<em>v</em>]</span><br /> This gives the correct value for each state.</p>
<p>Why is this correct? The total stats obtained not obtained by cloning are exactly <span class="math inline"><em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>T</em>)</span>, and the first <span class="math inline"><em>i</em></span> of them appeared when we added the first <span class="math inline"><em>i</em></span> characters. Consequently for each of these states we count the corresponding position at which it was processed. Therefore initially we have <span class="math inline"><em>c</em><em>n</em><em>t</em> = 1</span> for each such state, and <span class="math inline"><em>c</em><em>n</em><em>t</em> = 0</span> for all other.</p>
<p>Then we apply the following operation for each <span class="math inline"><em>v</em></span>: <span class="math inline"><em>c</em><em>n</em><em>t</em>[<em>l</em><em>i</em><em>n</em><em>k</em>(<em>v</em>)] += <em>c</em><em>n</em><em>t</em>[<em>v</em>]</span>. The meaning behind this is, that if a string <span class="math inline"><em>v</em></span> appears <span class="math inline"><em>c</em><em>n</em><em>t</em>[<em>v</em>]</span> times, then also all its suffixes appear at the exact same end positions, therefore also <span class="math inline"><em>c</em><em>n</em><em>t</em>[<em>v</em>]</span> times.</p>
<p>Why don't we overcount in this procedure (i.e. don't count some position twice)? Because we add the positions of a state to only one other state, so it can not happen that one state directs its positions to another state twice in two different ways.</p>
<p>Thus we can compute the quantities <span class="math inline"><em>c</em><em>n</em><em>t</em></span> for all states in the automaton in <span class="math inline"><em>O</em>(<em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>T</em>))</span> time.</p>
<p>After that answering a query by just looking up the value <span class="math inline"><em>c</em><em>n</em><em>t</em>[<em>t</em>]</span>, where <span class="math inline"><em>t</em></span> is the state corresponding to the pattern, if such a state exists. Otherwise answer with <span class="math inline">0</span>. Answering a query takes <span class="math inline"><em>O</em>(<em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>P</em>))</span> time.</p>
<h3 id="first-occurrence-position">First occurrence position</h3>
<p>Given a text <span class="math inline"><em>T</em></span> and multiple queries. For each query string <span class="math inline"><em>P</em></span> we want to find the position of the first occurrence of <span class="math inline"><em>P</em></span> in the string <span class="math inline"><em>T</em></span> (the position of the beginning of <span class="math inline"><em>P</em></span>).</p>
<p>We again construct a suffix automaton. Additionally we precompute the position <span class="math inline"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em><em>p</em><em>o</em><em>s</em></span> for all states in the automaton, i.e. for each state <span class="math inline"><em>v</em></span> we want to find the position <span class="math inline"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em><em>p</em><em>o</em><em>s</em>[<em>v</em>]</span> of the end of the first occurrence. In other words, we want to find in advance the minimal element of each set <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span> (since obviously cannot maintain all sets <span class="math inline"><em>e</em><em>n</em><em>d</em><em>p</em><em>o</em><em>s</em></span> explicitly).</p>
<p>To maintain these positions <span class="math inline"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em><em>p</em><em>o</em><em>s</em></span> we extend the function <code>sa_extend()</code>. When we create a new state <span class="math inline"><em>c</em><em>u</em><em>r</em></span>, we set: <br /><span class="math display"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em><em>p</em><em>o</em><em>s</em>(<em>c</em><em>u</em><em>r</em>)=<em>l</em><em>e</em><em>n</em>(<em>c</em><em>u</em><em>r</em>)−1</span><br /> And when we clone a vertex <span class="math inline"><em>q</em></span> as <span class="math inline"><em>c</em><em>l</em><em>o</em><em>n</em><em>e</em></span>, we set: <br /><span class="math display"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em><em>p</em><em>o</em><em>s</em>(<em>c</em><em>l</em><em>o</em><em>n</em><em>e</em>)=<em>f</em><em>i</em><em>r</em><em>s</em><em>t</em><em>p</em><em>o</em><em>s</em>(<em>q</em>)</span><br /> (since the only other option for a value would be <span class="math inline"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em><em>p</em><em>o</em><em>s</em>(<em>c</em><em>u</em><em>r</em>)</span> which is definitely too big)</p>
<p>Thus the answer for a query is simply <span class="math inline"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em><em>p</em><em>o</em><em>s</em>(<em>t</em>)−<em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>P</em>)+1</span>, where <span class="math inline"><em>t</em></span> is the state corresponding to the string <span class="math inline"><em>P</em></span>. Answering a query again takes only <span class="math inline"><em>O</em>(<em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>P</em>))</span> time.</p>
<h3 id="all-occurrence-positions">All occurrence positions</h3>
<p>This time we have to display all positions of the occurrences in the string <span class="math inline"><em>T</em></span>.</p>
<p>Again we construct a suffix automaton for the text <span class="math inline"><em>T</em></span>. Similar as in the previous task we compute the position <span class="math inline"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em><em>p</em><em>o</em><em>s</em></span> for all states.</p>
<p>Clearly <span class="math inline"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em><em>p</em><em>o</em><em>s</em>(<em>t</em>)</span> is part of the answer, if <span class="math inline"><em>t</em></span> is the state corresponding to a query string <span class="math inline"><em>P</em></span>. So we took into account the state of the automaton containing <span class="math inline"><em>P</em></span>. What other states do we need to take into account? All states that correspond to strings for which <span class="math inline"><em>P</em></span> is a suffix. In other words we need to find all the states that can reach the state <span class="math inline"><em>t</em></span> via suffix links.</p>
<p>Therefore to solve the problem we need to save for each state a list of suffix references leading to it. The answer to the query then will then contain all <span class="math inline"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em><em>p</em><em>o</em><em>s</em></span> for each state that we can find on a DFS / BFS starting from the state <span class="math inline"><em>t</em></span> using only the suffix references.</p>
<p>This workaround will work in time <span class="math inline"><em>O</em>(<em>a</em><em>n</em><em>s</em><em>w</em><em>e</em><em>r</em>(<em>P</em>))</span>, because we will not visit a state twice (because only one suffix link leaves each state, so there cannot be two different paths leading to the same state).</p>
<p>We only must take into account that two different states can have the same <span class="math inline"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em><em>p</em><em>o</em><em>s</em></span> value. This happens if one state was obtained by cloning another. However, this doesn't ruin the complexity, since each state can only have at most one clone.</p>
<p>Moreover, we can also get rid of the duplicate positions, if we don't output the positions from the cloned states. In fact a state, that a cloned state can reach, is also reachable from the original state. Thus if we remember the flag <code>is_cloned</code> for each state, we can simply ignore the cloned states and only output <span class="math inline"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em><em>p</em><em>o</em><em>s</em></span> for all other states.</p>
<p>Here are some implementation sketches:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> state {
    ...
    <span class="dt">bool</span> is_clone;
    <span class="dt">int</span> first_pos;
    vector&lt;<span class="dt">int</span>&gt; inv_link;
};

<span class="co">// after constructing the automaton</span>
<span class="kw">for</span> (<span class="dt">int</span> v = <span class="dv">1</span>; v &lt; sz; v++) {
    st[st[v].link].inv_link.push_back(v);
}

<span class="co">// output all positions of occurrences</span>
<span class="dt">void</span> output_all_occurrences(<span class="dt">int</span> v, <span class="dt">int</span> P_length) {
    <span class="kw">if</span> (!st[v].is_clone)
        cout &lt;&lt; st[v].first_pos - P_length + <span class="dv">1</span> &lt;&lt; endl;
    <span class="kw">for</span> (<span class="dt">int</span> u : st[v].inv_link)
        output_all_occurrences(u, P_length);
}</code></pre></div>
<h3 id="shortest-non-appearing-string">Shortest non-appearing string</h3>
<p>Given a string <span class="math inline"><em>S</em></span> and a certain alphabet. We have to find a string of smallest length, that doesn't appear in <span class="math inline"><em>S</em></span>.</p>
<p>We will apply dynamic programming on the suffix automaton built for the string <span class="math inline"><em>S</em></span>.</p>
<p>Let <span class="math inline"><em>d</em>[<em>v</em>]</span> be the answer for the node <span class="math inline"><em>v</em></span>, i.e. we already processed part of the substring, are currently in the state <span class="math inline"><em>v</em></span>, and want to find the smallest number of characters that have to be added to find a non-existent transition. Computing <span class="math inline"><em>d</em>[<em>v</em>]</span> is very simple. If there is not transition using at least one character of the alphabet, then <span class="math inline"><em>d</em>[<em>v</em>]=1</span>. Otherwise one character is not enough, and so we need to take the minimum of all answers of all transitions: <br /><span class="math display"><em>d</em>[<em>v</em>]=1 + min<sub><em>w</em> : (<em>v</em>, <em>w</em>, <em>c</em>)∈<em>S</em><em>A</em></sub><em>d</em>[<em>w</em>].</span><br /></p>
<p>The answer to the problem will be <span class="math inline"><em>d</em>[<em>t</em><sub>0</sub>]</span>, and the actual string can be restored using the computed array <span class="math inline"><em>d</em>[]</span>.</p>
<h3 id="longest-common-substring-of-two-strings">Longest common substring of two strings</h3>
<p>Given two strings <span class="math inline"><em>S</em></span> and <span class="math inline"><em>T</em></span>. We have to find the longest common substring, i.e. such a string <span class="math inline"><em>X</em></span> that appears as substring in <span class="math inline"><em>S</em></span> and also in <span class="math inline"><em>T</em></span>.</p>
<p>We construct a suffix automaton for the string <span class="math inline"><em>S</em></span>.</p>
<p>We will now take the string <span class="math inline"><em>T</em></span>, and for each prefix look for the longest suffix of this prefix in <span class="math inline"><em>S</em></span>. In other words, for each position in the string <span class="math inline"><em>T</em></span>, we want to find the longest common substring of <span class="math inline"><em>S</em></span> and <span class="math inline"><em>T</em></span> ending in that position.</p>
<p>For this we will use two variables, the <strong>current state</strong> <span class="math inline"><em>v</em></span>, and the <strong>current length</strong> <span class="math inline"><em>l</em></span>. These two variables will describe the current matching part: its length and the state that corresponds to it.</p>
<p>Initially <span class="math inline"><em>v</em> = <em>t</em><sub>0</sub></span> and <span class="math inline"><em>l</em> = 0</span>, i.e. the match is empty.</p>
<p>Now let us describe how we can add a character <span class="math inline"><em>T</em>[<em>i</em>]</span> and recalculate the answer for it.</p>
<ul>
<li>If there is a transition from <span class="math inline"><em>v</em></span> with the character <span class="math inline"><em>T</em>[<em>i</em>]</span>, then we simply follow the transition and increase <span class="math inline"><em>l</em></span> by one.</li>
<li>If there is no such transition, we have to shorten the current matching part, which means that we need to follow the suffix link: <br /><span class="math display"><em>v</em> = <em>l</em><em>i</em><em>n</em><em>k</em>(<em>v</em>)</span><br /> At the same time, the current length has to be shortened. Obviously we need to assign <span class="math inline"><em>l</em> = <em>l</em><em>e</em><em>n</em>(<em>v</em>)</span>, since after passing through the suffix link we end up in state whose corresponding longest string is a substring.</li>
<li>If there is still no transition using the required character, we repeat and again go through the suffix link and decrease <span class="math inline"><em>l</em></span>, until we find a transition or we reach the fictional state <span class="math inline">−1</span> (which means that the symbol <span class="math inline"><em>T</em>[<em>i</em>]</span> doesn't appear at all in <span class="math inline"><em>S</em></span>, so we assign <span class="math inline"><em>v</em> = <em>l</em> = 0</span>).</li>
</ul>
<p>The answer to the task will be the maximum of all the values <span class="math inline"><em>l</em></span>.</p>
<p>The complexity of this part is <span class="math inline"><em>O</em>(<em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>T</em>))</span>, since in one move we can either increase <span class="math inline"><em>l</em></span> by one, or make several passes through the suffix links, each one ends up reducing the value <span class="math inline"><em>l</em></span>.</p>
<p>Implementation:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">string lcs (string S, string T) {
    sa_init();
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; S.size(); i++)
        sa_extend(S[i]);
 
    <span class="dt">int</span> v = <span class="dv">0</span>, l = <span class="dv">0</span>, best = <span class="dv">0</span>, bestpos = <span class="dv">0</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; T.size(); i++) {
        <span class="kw">while</span> (v &amp;&amp; !st[v].next.count(T[i])) {
            v = st[v].link ;
            l = st[v].length ;
        }
        <span class="kw">if</span> (st[v].next.count(T[i])) {
            v = st [v].next[T[i]];
            l++;
        }
        <span class="kw">if</span> (l &gt; best) {
            best = l;
            bestpos = i;
        }
    }
    <span class="kw">return</span> t.substr(bestpos - best + <span class="dv">1</span>, best);
} </code></pre></div>
<h3 id="largest-common-substring-of-multiple-strings">Largest common substring of multiple strings</h3>
<p>There are <span class="math inline"><em>k</em></span> strings <span class="math inline"><em>S</em><sub><em>i</em></sub></span> given. We have to find the longest common substring, i.e. such a string <span class="math inline"><em>X</em></span> that appears as substring in each string <span class="math inline"><em>S</em><sub><em>i</em></sub></span>.</p>
<p>We join all strings into one large string <span class="math inline"><em>T</em></span>, separating the strings by a special characters <span class="math inline"><em>D</em><sub><em>i</em></sub></span> (one for each string): <br /><span class="math display"><em>T</em> = <em>S</em><sub>1</sub> + <em>D</em><sub>1</sub> + <em>S</em><sub>2</sub> + <em>D</em><sub>2</sub> + … + <em>S</em><sub><em>k</em></sub> + <em>D</em><sub><em>k</em></sub>.</span><br /></p>
<p>Then we construct the suffix automaton for the string <span class="math inline"><em>T</em></span>.</p>
<p>Now we need to find a string in the machine, which is contained in all the strings <span class="math inline"><em>S</em><sub><em>i</em></sub></span>, and this can be done by using the special added characters. Note that if a substring is included in some string <span class="math inline"><em>S</em><sub><em>j</em></sub></span>, then in the suffix automaton exists a path starting from this substring containing the character <span class="math inline"><em>D</em><sub><em>j</em></sub></span> and not containing the other characters <span class="math inline"><em>D</em><sub>1</sub>, …, <em>D</em><sub><em>j</em> − 1</sub>, <em>D</em><sub><em>j</em> + 1</sub>, …, <em>D</em><sub><em>k</em></sub></span>.</p>
<p>Thus we need to calculate the attainability, which tells us for each state of the machine and each symbol <span class="math inline"><em>D</em><sub><em>i</em></sub></span> if there exists such a path. This can easily be computed by DFS or BFS and dynamic programming. After that, the answer to the problem will be the string <span class="math inline"><em>l</em><em>o</em><em>n</em><em>g</em><em>e</em><em>s</em><em>t</em>(<em>v</em>)</span> for the state <span class="math inline"><em>v</em></span>, from which the paths were exists for all special characters.</p>
<h2 id="practice-problems">Practice Problems</h2>
<ul>
<li><a href="https://www.spoj.com/problems/SUBLEX/">SPOJ - SUBLEX</a></li>
</ul>
</body>
</html>
