<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<!--?title Lyndon factorization -->
<h1 id="lyndon-factorization">Lyndon factorization</h1>
<h2 id="lyndon-factorization-1">Lyndon factorization</h2>
<p>First let us define the notion of the Lyndon factorization.</p>
<p>A string is called <strong>simple</strong> (or a Lyndon word), if it is strictly <strong>smaller than</strong> any of its own nontrivial <strong>suffixes</strong>. Examples of simple strings are: <span class="math inline"><em>a</em></span>, <span class="math inline"><em>b</em></span>, <span class="math inline"><em>a</em><em>b</em></span>, <span class="math inline"><em>a</em><em>a</em><em>b</em></span>, <span class="math inline"><em>a</em><em>b</em><em>b</em></span>, <span class="math inline"><em>a</em><em>b</em><em>a</em><em>b</em><em>b</em></span>, <span class="math inline"><em>a</em><em>b</em><em>c</em><em>d</em></span>. It can be shown that a string is simple, if and only if it is strictly <strong>smaller than</strong> all its nontrivial <strong>cyclic shifts</strong>.</p>
<p>Next, let there be a given string <span class="math inline"><em>s</em></span>. The <strong>Lyndon factorization</strong> of the string <span class="math inline"><em>s</em></span> is a factorization <span class="math inline"><em>s</em> = <em>w</em><sub>1</sub><em>w</em><sub>2</sub>…<em>w</em><sub><em>k</em></sub></span>, where all strings <span class="math inline"><em>w</em><sub><em>i</em></sub></span> are simple, and they are in non-increasing order <span class="math inline"><em>w</em><sub>1</sub> ≥ <em>w</em><sub>2</sub> ≥ … ≥ <em>w</em><sub><em>k</em></sub></span>.</p>
<p>It can be shown, that for any string such a factorization exists and that it is unique.</p>
<h2 id="duval-algorithm">Duval algorithm</h2>
<p>The Duval algorithm constructs the Lyndon factorization in <span class="math inline"><em>O</em>(<em>n</em>)</span> time using <span class="math inline"><em>O</em>(1)</span> additional memory.</p>
<p>First let us introduce another notion: a string <span class="math inline"><em>t</em></span> is called <strong>pre-simple</strong>, if it has the form <span class="math inline">$t = w w \dots w \overline{w}$</span>, where <span class="math inline"><em>w</em></span> is a simple string and <span class="math inline">$\overline{w}$</span> is a prefix of <span class="math inline"><em>w</em></span> (possibly empty). A simple string is also pre-simple.</p>
<p>The Duval algorithm is greedy. At any point during its execution, the string <span class="math inline"><em>s</em></span> will actually be divided into three strings <span class="math inline"><em>s</em> = <em>s</em><sub>1</sub><em>s</em><sub>2</sub><em>s</em><sub>3</sub></span>, where the Lyndon factorization for <span class="math inline"><em>s</em><sub>1</sub></span> is already found and finalized, the string <span class="math inline"><em>s</em><sub>2</sub></span> is pre-simple (and we know the length of the simple string in it), and <span class="math inline"><em>s</em><sub>3</sub></span> is completely untouched. In each iteration the Duval algorithm takes the first character of the string <span class="math inline"><em>s</em><sub>3</sub></span> and tries to append it to the string <span class="math inline"><em>s</em><sub>2</sub></span>. It <span class="math inline"><em>s</em><sub>2</sub></span> is no longer pre-simple, then the Lyndon factorization for some part of <span class="math inline"><em>s</em><sub>2</sub></span> becomes known, and this part goes to <span class="math inline"><em>s</em><sub>1</sub></span>.</p>
<p>Let's describe the algorithm in more detail. The pointer <span class="math inline"><em>i</em></span> will always point to the beginning of the string <span class="math inline"><em>s</em><sub>2</sub></span>. The outer loop will be executed as long as <span class="math inline"><em>i</em> &lt; <em>n</em></span>. Inside the loop we use two additional pointers, <span class="math inline"><em>j</em></span> which points to the beginning of <span class="math inline"><em>s</em><sub>3</sub></span>, and <span class="math inline"><em>k</em></span> which points to the current character that we are currently comparing to. We want to add the character <span class="math inline"><em>s</em>[<em>j</em>]</span> to the string <span class="math inline"><em>s</em><sub>2</sub></span>, which requires a comparison with the character <span class="math inline"><em>s</em>[<em>k</em>]</span>. There can be three different cases:</p>
<ul>
<li><span class="math inline"><em>s</em>[<em>j</em>]=<em>s</em>[<em>k</em>]</span>: if this is the case, then adding the symbol <span class="math inline"><em>s</em>[<em>j</em>]</span> to <span class="math inline"><em>s</em><sub>2</sub></span> doesn't violate its pre-simplicity. So we simply increment the pointers <span class="math inline"><em>j</em></span> and <span class="math inline"><em>k</em></span>.</li>
<li><span class="math inline"><em>s</em>[<em>j</em>]&gt;<em>s</em>[<em>k</em>]</span>: here, the string <span class="math inline"><em>s</em><sub>2</sub> + <em>s</em>[<em>j</em>]</span> becomes simple. We can increment <span class="math inline"><em>j</em></span> and reset <span class="math inline"><em>k</em></span> back to the beginning of <span class="math inline"><em>s</em><sub>2</sub></span>, so that the next character can be compared with the beginning of of the simple word.</li>
<li><span class="math inline"><em>s</em>[<em>j</em>]&lt;<em>s</em>[<em>k</em>]</span>: the string <span class="math inline"><em>s</em><sub>2</sub> + <em>s</em>[<em>j</em>]</span> is no longer pre-simple. Therefore we will split the pre-simple string <span class="math inline"><em>s</em><sub>2</sub></span> into its simple strings and the remainder, possibly empty. The simple string will have the length <span class="math inline"><em>j</em> − <em>k</em></span>. In the next iteration we start again with the remaining <span class="math inline"><em>s</em><sub>2</sub></span>.</li>
</ul>
<h3 id="implementation">Implementation</h3>
<p>Here we present the implementation of the Duval algorithm, which will return the desired Lyndon factorization of a given string <span class="math inline"><em>s</em></span>.</p>
<p><code>cpp duval_algorithm vector&lt;string&gt; duval(string const&amp; s) {     int n = s.size();     int i = 0;     vector&lt;string&gt; factorization;     while (i &lt; n) {         int j = i + 1, k = i;         while (j &lt; n &amp;&amp; s[k] &lt;= s[j]) {             if (s[k] &lt; s[j])                 k = i;             else                 k++;             j++;         }         while (i &lt;= k) {             factorization.push_back(s.substr(i, j - k));             i += j - k;         }     }     return factorization; }</code></p>
<h3 id="complexity">Complexity</h3>
<p>Let us estimate the running time of this algorithm.</p>
<p>The <strong>outer while loop</strong> does not exceed <span class="math inline"><em>n</em></span> iterations, since at the end of each iteration <span class="math inline"><em>i</em></span> increases. Also the second inner while loop runs in <span class="math inline"><em>O</em>(<em>n</em>)</span>, since is only outputs the final factorization.</p>
<p>So we are only interested in the <strong>first inner while loop</strong>. How many iterations does it perform in the worst case? It's easy to see that the simple words that we identify in each iteration of the outer loop are longer than the remainder that we additionally compared. Therefore also the sum of the remainders will be smaller than <span class="math inline"><em>n</em></span>, which means that we only perform at most <span class="math inline"><em>O</em>(<em>n</em>)</span> iterations of the first inner while loop. In fact the total number of character comparisons will not exceed <span class="math inline">4<em>n</em> − 3</span>.</p>
<h2 id="finding-the-smallest-cyclic-shift">Finding the smallest cyclic shift</h2>
<p>Let there be a string <span class="math inline"><em>s</em></span>. We construct the Lyndon factorization for the string <span class="math inline"><em>s</em> + <em>s</em></span> (in <span class="math inline"><em>O</em>(<em>n</em>)</span> time). We will look for a simple string in the factorization, which starts at a position less than <span class="math inline"><em>n</em></span> (i.e. it starts in the first instance of <span class="math inline"><em>s</em></span>), and ends in a position greater than or equal to <span class="math inline"><em>n</em></span> (i.e. in the second instance) of <span class="math inline"><em>s</em></span>). It is stated, that the position of the start of this simple string will be the beginning of the desired smallest cyclic shift. This can be easily verified using the definition of the Lyndon decomposition.</p>
<p>The beginning of the simple block can be found easily - just remember the pointer <span class="math inline"><em>i</em></span> at the beginning of each iteration of the outer loop, which indicated the beginning of the current pre-simple string.</p>
<p>So we get the following implementation:</p>
<p><code>cpp smallest_cyclic_string string min_cyclic_string(string s) {     s += s;     int n = s.size();     int i = 0, ans = 0;     while (i &lt; n / 2) {         ans = i;         int j = i + 1, k = i;         while (j &lt; n &amp;&amp; s[k] &lt;= s[j]) {             if (s[k] &lt; s[j])                 k = i;             else                 k++;             j++;         }         while (i &lt;= k)             i += j - k;     }     return s.substr(ans, n / 2); }</code></p>
<h2 id="problems">Problems</h2>
<ul>
<li><a href="https://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=660">UVA #719 - Glass Beads</a></li>
</ul>
</body>
</html>
